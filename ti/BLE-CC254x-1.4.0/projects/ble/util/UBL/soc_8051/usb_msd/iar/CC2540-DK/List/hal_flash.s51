///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.30.1.41636 for 8051            20/Mar/2014  17:01:11 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\bl /
//                          e\util\UBL\soc_8051\usb_msd\hal\hal_flash.c       /
//    Command line       =  "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\hal\hal_flash.c" -D  /
//                          HAL_SB_BOOT_CODE -D UBL_BUILD -lC "C:\Texas       /
//                          Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UB /
//                          L\soc_8051\usb_msd\iar\CC2540-DK\List\" -lA       /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\" /
//                           --remarks -o "C:\Texas                           /
//                          Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UB /
//                          L\soc_8051\usb_msd\iar\CC2540-DK\Obj\" -e         /
//                          --debug --core=plain --dptr=16,1                  /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data_rom --nr_virtual_regs 16   /
//                          -I "C:\Texas Instruments\BLE-CC254x-1.4.0\Project /
//                          s\ble\util\UBL\soc_8051\usb_msd\iar\..\app\" -I   /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\" -I      /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\" -I  /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\iar\..\hal\usb\class /
//                          _msd\" -I "C:\Texas Instruments\BLE-CC254x-1.4.0\ /
//                          Projects\ble\util\UBL\soc_8051\usb_msd\iar\..\hal /
//                          \usb\library\" -Ohz --require_prototypes --mfc    /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\app\ubl_exec.c"      /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\app\ubl_main.c"      /
//                          "C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\b /
//                          le\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_ /
//                          descriptor_parser.c" "C:\Texas                    /
//                          Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UB /
//                          L\soc_8051\usb_msd\hal\usb\library\usb_framework. /
//                          c" "C:\Texas Instruments\BLE-CC254x-1.4.0\Project /
//                          s\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_inter /
//                          rupt.c" "C:\Texas Instruments\BLE-CC254x-1.4.0\Pr /
//                          ojects\ble\util\UBL\soc_8051\usb_msd\hal\usb\libr /
//                          ary\usb_standard_requests.c" "C:\Texas            /
//                          Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UB /
//                          L\soc_8051\usb_msd\hal\usb\usb_suspend.c"         /
//    List file          =  C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\bl /
//                          e\util\UBL\soc_8051\usb_msd\iar\CC2540-DK\List\ha /
//                          l_flash.s51                                       /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_flash

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V4
        EXTERN ?V5
        EXTERN ?V6
        EXTERN ?V7
        EXTERN ?V8
        EXTERN ?V9
        EXTERN ?V10
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?C_GPTR_LOAD
        EXTERN ?C_GPTR_STORE
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?G_EQ
        EXTERN ?L_MOV_TO_X
        EXTERN ?L_MOV_X
        EXTERN ?L_SHL
        EXTERN ?L_SUB_FROM_X
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK8_X_THREE
        EXTERN ?PUSH_XSTACK_I_THREE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?UL_DIV_MOD
        EXTERN ?UL_GT_X
        EXTERN ?US_SHR
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP102_8
        EXTERN __INIT_DATA_Z
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z
        EXTERN __low_level_init_call

        FUNCTION ??ChangeFeature,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        FUNCTION ??ChangeFeature?relay,0203H
        FUNCTION ??ConfigureEndpoints,0a1203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 19, STACK
        FUNCTION ??ConfigureEndpoints?relay,0203H
        PUBLIC ??HalFlashErase?relay
        FUNCTION ??HalFlashErase?relay,0203H
        PUBLIC ??HalFlashRead?relay
        FUNCTION ??HalFlashRead?relay,0203H
        PUBLIC ??HalFlashWrite?relay
        FUNCTION ??HalFlashWrite?relay,0203H
        FUNCTION ??gpioInit,080203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        FUNCTION ??gpioInit?relay,0203H
        PUBLIC ??main?relay
        FUNCTION ??main?relay,0203H
        PUBLIC ??ublAesAuth?relay
        FUNCTION ??ublAesAuth?relay,0203H
        PUBLIC ??ublAesCrypt?relay
        FUNCTION ??ublAesCrypt?relay,0203H
        PUBLIC ??ublCfg?relay
        FUNCTION ??ublCfg?relay,0203H
        PUBLIC ??ublExec?relay
        FUNCTION ??ublExec?relay,0203H
        PUBLIC ??ublInit?relay
        FUNCTION ??ublInit?relay,0203H
        PUBLIC ??ublJump?relay
        FUNCTION ??ublJump?relay,0203H
        PUBLIC ??ublMassErase?relay
        FUNCTION ??ublMassErase?relay,0203H
        PUBLIC ??usbdpFindNext?relay
        FUNCTION ??usbdpFindNext?relay,0203H
        PUBLIC ??usbdpGetConfigurationDesc?relay
        FUNCTION ??usbdpGetConfigurationDesc?relay,0203H
        PUBLIC ??usbdpGetDeviceDesc?relay
        FUNCTION ??usbdpGetDeviceDesc?relay,0203H
        PUBLIC ??usbdpGetInterfaceDesc?relay
        FUNCTION ??usbdpGetInterfaceDesc?relay,0203H
        PUBLIC ??usbdpGetStringDesc?relay
        FUNCTION ??usbdpGetStringDesc?relay,0203H
        PUBLIC ??usbdpInit?relay
        FUNCTION ??usbdpInit?relay,0203H
        PUBLIC ??usbfwInit?relay
        FUNCTION ??usbfwInit?relay,0203H
        PUBLIC ??usbfwReadFifo?relay
        FUNCTION ??usbfwReadFifo?relay,0203H
        PUBLIC ??usbfwResetHandler?relay
        FUNCTION ??usbfwResetHandler?relay,0203H
        PUBLIC ??usbfwSetAllEpStatus?relay
        FUNCTION ??usbfwSetAllEpStatus?relay,0203H
        PUBLIC ??usbfwSetupHandler?relay
        FUNCTION ??usbfwSetupHandler?relay,0203H
        PUBLIC ??usbfwWriteFifo?relay
        FUNCTION ??usbfwWriteFifo?relay,0203H
        PUBLIC ??usbirqHandler?relay
        FUNCTION ??usbirqHandler?relay,0203H
        PUBLIC ??usbirqInit?relay
        FUNCTION ??usbirqInit?relay,0203H
        PUBLIC ??usbsrClearFeature?relay
        FUNCTION ??usbsrClearFeature?relay,0203H
        PUBLIC ??usbsrGetConfiguration?relay
        FUNCTION ??usbsrGetConfiguration?relay,0203H
        PUBLIC ??usbsrGetDescriptor?relay
        FUNCTION ??usbsrGetDescriptor?relay,0203H
        PUBLIC ??usbsrGetInterface?relay
        FUNCTION ??usbsrGetInterface?relay,0203H
        PUBLIC ??usbsrGetStatus?relay
        FUNCTION ??usbsrGetStatus?relay,0203H
        PUBLIC ??usbsrSetAddress?relay
        FUNCTION ??usbsrSetAddress?relay,0203H
        PUBLIC ??usbsrSetConfiguration?relay
        FUNCTION ??usbsrSetConfiguration?relay,0203H
        PUBLIC ??usbsrSetFeature?relay
        FUNCTION ??usbsrSetFeature?relay,0203H
        PUBLIC ??usbsrSetInterface?relay
        FUNCTION ??usbsrSetInterface?relay,0203H
        PUBLIC ??usbsuspDoRemoteWakeup?relay
        FUNCTION ??usbsuspDoRemoteWakeup?relay,0203H
        PUBWEAK ADCCON1
        PUBWEAK ADCCON3
        PUBWEAK ADCH
        PUBWEAK CLKCONCMD
        PUBWEAK DMA0CFGH
        PUBWEAK DMA0CFGL
        PUBWEAK DMAARM
        PUBWEAK DMAIRQ
        PUBLIC HalFlashErase
        FUNCTION HalFlashErase,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC HalFlashRead
        FUNCTION HalFlashRead,080203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC HalFlashWrite
        FUNCTION HalFlashWrite,080203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBWEAK IEN2
        PUBWEAK MEMCTR
        PUBWEAK P2IFG
        PUBWEAK P2INP
        PUBWEAK SLEEPSTA
        PUBWEAK ST0
        PUBWEAK ST1
        PUBWEAK ST2
        PUBLIC UBL_RC_IMG_PG_BEG
        PUBLIC UBL_RC_IMG_PG_END
        PUBWEAK WDCTL
        PUBWEAK _A_IEN0
        PUBWEAK _A_IEN1
        PUBWEAK _A_IRCON2
        PUBWEAK __Constant_7d
        PUBLIC __low_level_init
        FUNCTION __low_level_init,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC dmaCh0
        PUBLIC hexDigit
        PUBLIC main
        FUNCTION main,021a03H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC pFnSuspendEnterHook
        PUBLIC pFnSuspendExitHook
        PUBLIC pgBuf
        PUBLIC ublAesAuth
        FUNCTION ublAesAuth,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC ublAesCrypt
        FUNCTION ublAesCrypt,0203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC ublCfg
        FUNCTION ublCfg,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC ublExec
        FUNCTION ublExec,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC ublInit
        FUNCTION ublInit,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        PUBLIC ublJump
        FUNCTION ublJump,080203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC ublMD
        PUBLIC ublMassErase
        FUNCTION ublMassErase,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        PUBLIC usbSetupData
        PUBLIC usbSetupHeader
        PUBLIC usbdpFindNext
        FUNCTION usbdpFindNext,0203H
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbdpGetConfigurationDesc
        FUNCTION usbdpGetConfigurationDesc,0a1203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbdpGetDeviceDesc
        FUNCTION usbdpGetDeviceDesc,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbdpGetInterfaceDesc
        FUNCTION usbdpGetInterfaceDesc,0a1203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbdpGetStringDesc
        FUNCTION usbdpGetStringDesc,080203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC usbdpInit
        FUNCTION usbdpInit,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwData
        PUBLIC usbfwInit
        FUNCTION usbfwInit,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwReadFifo
        FUNCTION usbfwReadFifo,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC usbfwResetHandler
        FUNCTION usbfwResetHandler,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbfwSetAllEpStatus
        FUNCTION usbfwSetAllEpStatus,080203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbfwSetupHandler
        FUNCTION usbfwSetupHandler,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC usbfwWriteFifo
        FUNCTION usbfwWriteFifo,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC usbirqData
        PUBLIC usbirqHandler
        FUNCTION usbirqHandler,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbirqInit
        FUNCTION usbirqInit,080203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbsrClearFeature
        FUNCTION usbsrClearFeature,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetConfiguration
        FUNCTION usbsrGetConfiguration,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetDescriptor
        FUNCTION usbsrGetDescriptor,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC usbsrGetInterface
        FUNCTION usbsrGetInterface,080203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 11, STACK
        PUBLIC usbsrGetStatus
        FUNCTION usbsrGetStatus,080203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbsrSetAddress
        FUNCTION usbsrSetAddress,0203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetConfiguration
        FUNCTION usbsrSetConfiguration,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbsrSetFeature
        FUNCTION usbsrSetFeature,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetInterface
        FUNCTION usbsrSetInterface,0a1203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbsuspDoRemoteWakeup
        FUNCTION usbsuspDoRemoteWakeup,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
        
          CFI Common cfiCommon2 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon2
        
        
          CFI Common cfiCommon3 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` Undefined
          CFI `B.BR0` Undefined
          CFI `B.BR1` Undefined
          CFI `B.BR2` Undefined
          CFI `B.BR3` Undefined
          CFI `B.BR4` Undefined
          CFI `B.BR5` Undefined
          CFI `B.BR6` Undefined
          CFI `B.BR7` Undefined
          CFI `VB.BR8` Undefined
          CFI `VB.BR9` Undefined
          CFI `VB.BR10` Undefined
          CFI `VB.BR11` Undefined
          CFI `VB.BR12` Undefined
          CFI `VB.BR13` Undefined
          CFI `VB.BR14` Undefined
          CFI `VB.BR15` Undefined
          CFI VB Undefined
          CFI B Undefined
          CFI A Undefined
          CFI PSW Undefined
          CFI DPL0 Undefined
          CFI DPH0 Undefined
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 Undefined
          CFI R7 Undefined
          CFI V0 Undefined
          CFI V1 Undefined
          CFI V2 Undefined
          CFI V3 Undefined
          CFI V4 Undefined
          CFI V5 Undefined
          CFI V6 Undefined
          CFI V7 Undefined
          CFI V8 Undefined
          CFI V9 Undefined
          CFI V10 Undefined
          CFI V11 Undefined
          CFI V12 Undefined
          CFI V13 Undefined
          CFI V14 Undefined
          CFI V15 Undefined
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon3
        
halMcuWaitMs        SYMBOL "halMcuWaitMs"
??halMcuWaitMs?relay SYMBOL "?relay", halMcuWaitMs
memcmp              SYMBOL "memcmp"
??memcmp?relay      SYMBOL "?relay", memcmp
memcpy              SYMBOL "memcpy"
??memcpy?relay      SYMBOL "?relay", memcpy
usb_msd_init        SYMBOL "usb_msd_init"
??usb_msd_init?relay SYMBOL "?relay", usb_msd_init
usb_msd_poll        SYMBOL "usb_msd_poll"
??usb_msd_poll?relay SYMBOL "?relay", usb_msd_poll
usb_msd_uninit      SYMBOL "usb_msd_uninit"
??usb_msd_uninit?relay SYMBOL "?relay", usb_msd_uninit
usbcrHookProcessIn  SYMBOL "usbcrHookProcessIn"
??usbcrHookProcessIn?relay SYMBOL "?relay", usbcrHookProcessIn
usbcrHookProcessOut SYMBOL "usbcrHookProcessOut"
??usbcrHookProcessOut?relay SYMBOL "?relay", usbcrHookProcessOut
usbirqHookProcessEvents SYMBOL "usbirqHookProcessEvents"
??usbirqHookProcessEvents?relay SYMBOL "?relay", usbirqHookProcessEvents
usbsrHookClearFeature SYMBOL "usbsrHookClearFeature"
??usbsrHookClearFeature?relay SYMBOL "?relay", usbsrHookClearFeature
usbsrHookProcessEvent SYMBOL "usbsrHookProcessEvent"
??usbsrHookProcessEvent?relay SYMBOL "?relay", usbsrHookProcessEvent
usbsrHookSetFeature SYMBOL "usbsrHookSetFeature"
??usbsrHookSetFeature?relay SYMBOL "?relay", usbsrHookSetFeature
usbvrHookProcessIn  SYMBOL "usbvrHookProcessIn"
??usbvrHookProcessIn?relay SYMBOL "?relay", usbvrHookProcessIn
usbvrHookProcessOut SYMBOL "usbvrHookProcessOut"
??usbvrHookProcessOut?relay SYMBOL "?relay", usbvrHookProcessOut
HalFlashErase       SYMBOL "HalFlashErase"
??HalFlashErase?relay SYMBOL "?relay", HalFlashErase
HalFlashRead        SYMBOL "HalFlashRead"
??HalFlashRead?relay SYMBOL "?relay", HalFlashRead
HalFlashWrite       SYMBOL "HalFlashWrite"
??HalFlashWrite?relay SYMBOL "?relay", HalFlashWrite
main                SYMBOL "main"
??main?relay        SYMBOL "?relay", main
ublAesAuth          SYMBOL "ublAesAuth"
??ublAesAuth?relay  SYMBOL "?relay", ublAesAuth
ublAesCrypt         SYMBOL "ublAesCrypt"
??ublAesCrypt?relay SYMBOL "?relay", ublAesCrypt
ublCfg              SYMBOL "ublCfg"
??ublCfg?relay      SYMBOL "?relay", ublCfg
ublExec             SYMBOL "ublExec"
??ublExec?relay     SYMBOL "?relay", ublExec
ublInit             SYMBOL "ublInit"
??ublInit?relay     SYMBOL "?relay", ublInit
ublJump             SYMBOL "ublJump"
??ublJump?relay     SYMBOL "?relay", ublJump
ublMassErase        SYMBOL "ublMassErase"
??ublMassErase?relay SYMBOL "?relay", ublMassErase
usbdpFindNext       SYMBOL "usbdpFindNext"
??usbdpFindNext?relay SYMBOL "?relay", usbdpFindNext
usbdpGetConfigurationDesc SYMBOL "usbdpGetConfigurationDesc"
??usbdpGetConfigurationDesc?relay SYMBOL "?relay", usbdpGetConfigurationDesc
usbdpGetDeviceDesc  SYMBOL "usbdpGetDeviceDesc"
??usbdpGetDeviceDesc?relay SYMBOL "?relay", usbdpGetDeviceDesc
usbdpGetInterfaceDesc SYMBOL "usbdpGetInterfaceDesc"
??usbdpGetInterfaceDesc?relay SYMBOL "?relay", usbdpGetInterfaceDesc
usbdpGetStringDesc  SYMBOL "usbdpGetStringDesc"
??usbdpGetStringDesc?relay SYMBOL "?relay", usbdpGetStringDesc
usbdpInit           SYMBOL "usbdpInit"
??usbdpInit?relay   SYMBOL "?relay", usbdpInit
usbfwInit           SYMBOL "usbfwInit"
??usbfwInit?relay   SYMBOL "?relay", usbfwInit
usbfwReadFifo       SYMBOL "usbfwReadFifo"
??usbfwReadFifo?relay SYMBOL "?relay", usbfwReadFifo
usbfwResetHandler   SYMBOL "usbfwResetHandler"
??usbfwResetHandler?relay SYMBOL "?relay", usbfwResetHandler
usbfwSetAllEpStatus SYMBOL "usbfwSetAllEpStatus"
??usbfwSetAllEpStatus?relay SYMBOL "?relay", usbfwSetAllEpStatus
usbfwSetupHandler   SYMBOL "usbfwSetupHandler"
??usbfwSetupHandler?relay SYMBOL "?relay", usbfwSetupHandler
usbfwWriteFifo      SYMBOL "usbfwWriteFifo"
??usbfwWriteFifo?relay SYMBOL "?relay", usbfwWriteFifo
usbirqHandler       SYMBOL "usbirqHandler"
??usbirqHandler?relay SYMBOL "?relay", usbirqHandler
usbirqInit          SYMBOL "usbirqInit"
??usbirqInit?relay  SYMBOL "?relay", usbirqInit
usbsrClearFeature   SYMBOL "usbsrClearFeature"
??usbsrClearFeature?relay SYMBOL "?relay", usbsrClearFeature
usbsrGetConfiguration SYMBOL "usbsrGetConfiguration"
??usbsrGetConfiguration?relay SYMBOL "?relay", usbsrGetConfiguration
usbsrGetDescriptor  SYMBOL "usbsrGetDescriptor"
??usbsrGetDescriptor?relay SYMBOL "?relay", usbsrGetDescriptor
usbsrGetInterface   SYMBOL "usbsrGetInterface"
??usbsrGetInterface?relay SYMBOL "?relay", usbsrGetInterface
usbsrGetStatus      SYMBOL "usbsrGetStatus"
??usbsrGetStatus?relay SYMBOL "?relay", usbsrGetStatus
usbsrSetAddress     SYMBOL "usbsrSetAddress"
??usbsrSetAddress?relay SYMBOL "?relay", usbsrSetAddress
usbsrSetConfiguration SYMBOL "usbsrSetConfiguration"
??usbsrSetConfiguration?relay SYMBOL "?relay", usbsrSetConfiguration
usbsrSetFeature     SYMBOL "usbsrSetFeature"
??usbsrSetFeature?relay SYMBOL "?relay", usbsrSetFeature
usbsrSetInterface   SYMBOL "usbsrSetInterface"
??usbsrSetInterface?relay SYMBOL "?relay", usbsrSetInterface
usbsuspDoRemoteWakeup SYMBOL "usbsuspDoRemoteWakeup"
??usbsuspDoRemoteWakeup?relay SYMBOL "?relay", usbsuspDoRemoteWakeup

        EXTERN ??halMcuWaitMs?relay
        FUNCTION ??halMcuWaitMs?relay,00H
        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memcpy?relay
        FUNCTION ??memcpy?relay,00H
        EXTERN ??usb_msd_init?relay
        FUNCTION ??usb_msd_init?relay,00H
        EXTERN ??usb_msd_poll?relay
        FUNCTION ??usb_msd_poll?relay,00H
        EXTERN ??usb_msd_uninit?relay
        FUNCTION ??usb_msd_uninit?relay,00H
        EXTERN ??usbcrHookProcessIn?relay
        FUNCTION ??usbcrHookProcessIn?relay,00H
        EXTERN ??usbcrHookProcessOut?relay
        FUNCTION ??usbcrHookProcessOut?relay,00H
        EXTERN ??usbirqHookProcessEvents?relay
        FUNCTION ??usbirqHookProcessEvents?relay,00H
        EXTERN ??usbsrHookClearFeature?relay
        FUNCTION ??usbsrHookClearFeature?relay,00H
        EXTERN ??usbsrHookProcessEvent?relay
        FUNCTION ??usbsrHookProcessEvent?relay,00H
        EXTERN ??usbsrHookSetFeature?relay
        FUNCTION ??usbsrHookSetFeature?relay,00H
        EXTERN ??usbvrHookProcessIn?relay
        FUNCTION ??usbvrHookProcessIn?relay,00H
        EXTERN ??usbvrHookProcessOut?relay
        FUNCTION ??usbvrHookProcessOut?relay,00H
        EXTERN halMcuWaitMs
        FUNCTION halMcuWaitMs,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbDescriptorMarker
        EXTERN usb_msd_init
        FUNCTION usb_msd_init,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usb_msd_poll
        FUNCTION usb_msd_poll,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usb_msd_uninit
        FUNCTION usb_msd_uninit,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbcrHookProcessIn
        FUNCTION usbcrHookProcessIn,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbcrHookProcessOut
        FUNCTION usbcrHookProcessOut,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbirqHookProcessEvents
        FUNCTION usbirqHookProcessEvents,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookClearFeature
        FUNCTION usbsrHookClearFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookProcessEvent
        FUNCTION usbsrHookProcessEvent,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookSetFeature
        FUNCTION usbsrHookSetFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbvrHookProcessIn
        FUNCTION usbvrHookProcessIn,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbvrHookProcessOut
        FUNCTION usbvrHookProcessOut,0602H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\hal_flash.c
//    1 /**************************************************************************************************
//    2   Filename:       hal_flash.c
//    3   Revised:        $Date: 2012-08-31 11:31:40 -0700 (Fri, 31 Aug 2012) $
//    4   Revision:       $Revision: 31449 $
//    5 
//    6   Description: This file contains the interface to the H/W Flash driver.
//    7 
//    8 
//    9   Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 #include "hal_board_cfg.h"

        ASEGN SFR_AN:DATA:NOROOT,08bH
// unsigned char volatile __sfr P2IFG
P2IFG:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,095H
// unsigned char volatile __sfr ST0
ST0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,096H
// unsigned char volatile __sfr ST1
ST1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,097H
// unsigned char volatile __sfr ST2
ST2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09aH
// unsigned char volatile __sfr IEN2
IEN2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09dH
// unsigned char volatile __sfr SLEEPSTA
SLEEPSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b4H
// unsigned char volatile __sfr ADCCON1
ADCCON1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b6H
// unsigned char volatile __sfr ADCCON3
ADCCON3:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b8H
// union <unnamed> volatile __sfr _A_IEN1
_A_IEN1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0bbH
// unsigned char volatile __sfr ADCH
ADCH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c6H
// unsigned char volatile __sfr CLKCONCMD
CLKCONCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c7H
// unsigned char volatile __sfr MEMCTR
MEMCTR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c9H
// unsigned char volatile __sfr WDCTL
WDCTL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d1H
// unsigned char volatile __sfr DMAIRQ
DMAIRQ:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d4H
// unsigned char volatile __sfr DMA0CFGL
DMA0CFGL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d5H
// unsigned char volatile __sfr DMA0CFGH
DMA0CFGH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d6H
// unsigned char volatile __sfr DMAARM
DMAARM:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e8H
// union <unnamed> volatile __sfr _A_IRCON2
_A_IRCON2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f7H
// unsigned char volatile __sfr P2INP
P2INP:
        DATA8
        DS 1
//   46 #include "hal_dma.h"
//   47 #include "hal_flash.h"
//   48 #include "hal_mcu.h"
//   49 #include "hal_types.h"
//   50 
//   51 /**************************************************************************************************
//   52  * @fn          HalFlashRead
//   53  *
//   54  * @brief       This function reads 'cnt' bytes from the internal flash.
//   55  *
//   56  * input parameters
//   57  *
//   58  * @param       pg - A valid flash page number.
//   59  * @param       offset - A valid offset into the page.
//   60  * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
//   61  * @param       cnt - A valid number of bytes to read.
//   62  *
//   63  * output parameters
//   64  *
//   65  * None.
//   66  *
//   67  * @return      None.
//   68  **************************************************************************************************
//   69  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   70 void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
HalFlashRead:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HalFlashRead
        CODE
//   71 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0,R1
//   72   // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
//   73   uint8 *pData = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
//   74                  ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
        MOV     A,#0xf
        ANL     A,?V0
        MOV     ?V2,A
        MOV     ?V3,#0x0
        MOV     A,#0xb
        MOV     R0,#?V2
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,#0x0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#-0x80
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x0
        MOV     A,R1
        ADDC    A,?V3
        MOV     R1,A
//   75   uint8 memctr = MEMCTR;  // Save to restore.
        MOV     A,0xc7
        MOV     ?V1,A
//   76 
//   77 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//   78   halIntState_t is;
//   79 #endif
//   80 
//   81   pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
//   82 
//   83 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//   84   HAL_ENTER_CRITICAL_SECTION(is);
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     ?V2,A
        CLR     0xa8.7
//   85 #endif
//   86 
//   87   // Calculate and map the containing flash bank into XDATA.
//   88   MEMCTR = (MEMCTR & 0xF8) | pg;
        MOV     A,?V0
        SWAP    A
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,0xc7
        ANL     A,#0xf8
        ORL     A,R2
        MOV     0xc7,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine32_0 & 0xFFFF
??CrossCallReturnLabel_41:
        SJMP    ??HalFlashRead_0
//   89 
//   90   while (cnt--)
//   91   {
//   92     *buf++ = *pData++;
??HalFlashRead_1:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//   93   }
??HalFlashRead_0:
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     A,R6
        ADD     A,#-0x1
        DEC     R2
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R3,A
        MOV     A,R6
        ORL     A,R7
        JNZ     ??HalFlashRead_1
//   94 
//   95   MEMCTR = memctr;
        MOV     0xc7,?V1
//   96 
//   97 #if (!defined HAL_OAD_BOOT_CODE) && (!defined HAL_OTA_BOOT_CODE)
//   98   HAL_EXIT_CRITICAL_SECTION(is);
        MOV     A,?V2
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
//   99 #endif
//  100 }
        LJMP    ?Subroutine0 & 0xFFFF
          CFI EndBlock cfiBlock0
        REQUIRE MEMCTR
        REQUIRE _A_IEN0
//  101 
//  102 /**************************************************************************************************
//  103  * @fn          HalFlashWrite
//  104  *
//  105  * @brief       This function writes 'cnt' bytes to the internal flash.
//  106  *
//  107  * input parameters
//  108  *
//  109  * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
//  110  * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
//  111  * @param       cnt - Number of 4-byte blocks to write.
//  112  *
//  113  * output parameters
//  114  *
//  115  * None.
//  116  *
//  117  * @return      None.
//  118  **************************************************************************************************
//  119  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  120 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
HalFlashWrite:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HalFlashWrite
        CODE
//  121 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  122   halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
//  123 
//  124   HAL_DMA_SET_SOURCE(ch, buf);
        MOV     A,R5
        MOV     DPTR,#dmaCh0
        MOVX    @DPTR,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
//  125   HAL_DMA_SET_DEST(ch, &FWDATA);
        INC     DPTR
        MOV     A,#0x62
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x73
        MOVX    @DPTR,A
//  126   HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine13 & 0xFFFF
//  127   HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
??CrossCallReturnLabel_11:
        RLC     A
        RLC     A
        ANL     A,#0xfc
        MOV     DPTR,#dmaCh0 + 5
        MOVX    @DPTR,A
        MOV     A,#0x6
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#dmaCh0 + 4
        MOVX    @DPTR,A
//  128   HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
//  129   HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
//  130   HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
        MOV     DPTR,#dmaCh0 + 6
        MOV     A,#0x12
        MOVX    @DPTR,A
//  131   HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
//  132   HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
//  133   // The DMA is to be polled and shall not issue an IRQ upon completion.
//  134   HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
//  135   HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
//  136   HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
        INC     DPTR
        MOV     A,#0x42
        MOVX    @DPTR,A
//  137   HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
        MOV     0xd1,#-0x2
//  138   HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
        MOV     0xd6,#0x1
//  139 
//  140   FADDRL = (uint8)addr;
        MOV     A,R2
        MOV     DPTR,#0x6271
        MOVX    @DPTR,A
//  141   FADDRH = (uint8)(addr >> 8);
        MOV     A,R3
        INC     DPTR
        MOVX    @DPTR,A
//  142   FCTL |= 0x02;         // Trigger the DMA writes.
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
//  143   while (FCTL & 0x80);  // Wait until writing is done.
??HalFlashWrite_0:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JC      ??HalFlashWrite_0
//  144 }
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock1
        REQUIRE DMAIRQ
        REQUIRE DMAARM
//  145 
//  146 /**************************************************************************************************
//  147  * @fn          HalFlashErase
//  148  *
//  149  * @brief       This function erases the specified page of the internal flash.
//  150  *
//  151  * input parameters
//  152  *
//  153  * @param       pg - A valid flash page number to erase.
//  154  *
//  155  * output parameters
//  156  *
//  157  * None.
//  158  *
//  159  * @return      None.
//  160  **************************************************************************************************
//  161  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  162 void HalFlashErase(uint8 pg)
HalFlashErase:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HalFlashErase
        CODE
//  163 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  164   FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        LJMP    ?Subroutine2 & 0xFFFF
          CFI EndBlock cfiBlock2
//  165   FCTL |= 0x01;
//  166 }
//  167 
//  168 /**************************************************************************************************
//  169 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_exec.c
//    1 /**************************************************************************************************
//    2   Filename:       ubl_exec.c
//    3   Revised:        $Date: 2012-09-07 14:26:14 -0700 (Fri, 07 Sep 2012) $
//    4   Revision:       $Revision: 31498 $
//    5 
//    6   Description:
//    7 
//    8   This module implements the executive functionality of a Universal Boot Loader
//    9   for an 8051-based SOC using the USB transport by MSD.
//   10 
//   11 
//   12   Copyright 2011-2012 Texas Instruments Incorporated. All rights reserved.
//   13 
//   14   IMPORTANT: Your use of this Software is limited to those specific rights
//   15   granted under the terms of a software license agreement between the user
//   16   who downloaded the software, his/her employer (which must be your employer)
//   17   and Texas Instruments Incorporated (the "License").  You may not use this
//   18   Software unless you agree to abide by the terms of the License. The License
//   19   limits your use, and you acknowledge, that the Software may not be modified,
//   20   copied or distributed unless embedded on a Texas Instruments microcontroller
//   21   or used solely and exclusively in conjunction with a Texas Instruments radio
//   22   frequency transceiver, which is integrated into your product.  Other than for
//   23   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   24   works of, modify, distribute, perform, display or sell this Software and/or
//   25   its documentation for any purpose.
//   26 
//   27   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   28   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   29   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   30   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   31   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   32   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   33   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   34   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   35   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   36   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   37   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   38 
//   39   Should you have any questions regarding your right to use this Software,
//   40   contact Texas Instruments Incorporated at www.TI.com.
//   41 **************************************************************************************************/
//   42 
//   43 /* ------------------------------------------------------------------------------------------------
//   44  *                                          Includes
//   45  * ------------------------------------------------------------------------------------------------
//   46  */
//   47 
//   48 #include <stddef.h>
//   49 #include <string.h>
//   50 
//   51 #include "hal_board_cfg.h"
//   52 #include "hal_dma.h"
//   53 #include "hal_flash.h"
//   54 #include "hal_types.h"
//   55 #include "ubl_app.h"
//   56 #include "ubl_exec.h"
//   57 #include "usb_msd.h"
//   58 
//   59 /* ------------------------------------------------------------------------------------------------
//   60  *                                          Constants
//   61  * ------------------------------------------------------------------------------------------------
//   62  */
//   63 
//   64 #if !defined HAL_DONGLE_NANO
//   65 #define UBL_GPIO_USE
//   66 #endif
//   67 
//   68 // Define the checksum-subset of the Meta Data for checksum calculation and copying so as not to
//   69 // overwrite ong.
//   70 #define UBL_MD_CHKLEN  (offsetof(ublMetaData_t, cntDnForced) - offsetof(ublMetaData_t, chkMD))
//   71 

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//   72 static const uint8 unlockedSecKey[32] =
??unlockedSecKey:
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
//   73 {
//   74   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
//   75   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
//   76 };
//   77 
//   78 /***                 The following are "Write" addresses for HalFlashWrite().                  ***/
//   79 #define UBL_META_DATA_ADDR_WR  \ 
//   80   ((uint16)(UBL_META_DATA_PAGE * ((uint16)(HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE))) + \ 
//   81                                   (uint16)(UBL_META_DATA_IDX / HAL_FLASH_WORD_SIZE))
//   82 
//   83 #define UBL_CNTDN_FORCED_ADDR (UBL_META_DATA_ADDR_WR + \ 
//   84                               (offsetof(ublMetaData_t, cntDnForced) / HAL_FLASH_WORD_SIZE))
//   85 #define UBL_CNTDN_SECKEY_ADDR (UBL_META_DATA_ADDR_WR + \ 
//   86                               (offsetof(ublMetaData_t, cntDnSecKey) / HAL_FLASH_WORD_SIZE))
//   87 /***                  The above are "Write" addresses for HalFlashWrite().                    ***/
//   88 
//   89 // Allow test & development with final structures and memeory map without the burden of having to
//   90 // encrypt and sign every image to download until ready with the production build.
//   91 #if !defined UBL_SECURE
//   92 #define UBL_SECURE                   FALSE
//   93 #endif
//   94 
//   95 #if UBL_SECURE
//   96 static const uint8 aesKey[KEY_BLENGTH] = {
//   97   // This dummy key must be replaced by a randomly generated key that is kept secret.
//   98   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
//   99 };
//  100 #endif
//  101 
//  102 // Set UBL_SIGNER=TRUE in order to create a special boot loader that will accept
//  103 // an un-encrypted/un-authenticated image via download and then sign it and send it back
//  104 // with encryption on the read back.
//  105 #if !defined UBL_SIGNER
//  106 #define UBL_SIGNER                   FALSE
//  107 #endif
//  108 
//  109 #if UBL_SIGNER
//  110 #if !UBL_SECURE
//  111 #error Mismatched definitions for UBL_SIGNER and UBL_SECURE.
//  112 #else
//  113 #warning You built a special "Signing" boot loader - do not release to market ... internal use only.
//  114 #endif
//  115 #endif
//  116 
//  117 /* ------------------------------------------------------------------------------------------------
//  118  *                                           Macros
//  119  * ------------------------------------------------------------------------------------------------
//  120  */
//  121 
//  122 #define UBL_READ_ST(STCNT) st (             \ 
//  123   do {  /* Get the sleep timer count; ST0 must be read first & re-read to verify. */\ 
//  124     ((uint8 *) &(STCNT))[0] = ST0;          \ 
//  125   } while (((uint8 *) &(STCNT))[0] != ST0); \ 
//  126   ((uint8 *) &(STCNT))[1] = ST1;            \ 
//  127   ((uint8 *) &(STCNT))[2] = ST2;            \ 
//  128   ((uint8 *) &(STCNT))[3] = 0;              \ 
//  129 )
//  130 
//  131 /* ------------------------------------------------------------------------------------------------
//  132  *                                       Global Variables
//  133  * ------------------------------------------------------------------------------------------------
//  134  */
//  135 

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  136 const uint8 UBL_RC_IMG_PG_BEG = UBL_PAGE_FIRST;
UBL_RC_IMG_PG_BEG:
        DB 1

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  137 const uint8 UBL_RC_IMG_PG_END = UBL_PAGE_LAST;
UBL_RC_IMG_PG_END:
        DB 119
//  138 
//  139 /* ------------------------------------------------------------------------------------------------
//  140  *                                       Global Variables
//  141  * ------------------------------------------------------------------------------------------------
//  142  */
//  143 

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  144 __no_init uint8 pgBuf[HAL_FLASH_PAGE_SIZE];  // RAM (XDATA) buffer for an Rx/Tx flash page.
pgBuf:
        DS 2048

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  145 __no_init ublMetaData_t ublMD;
ublMD:
        DS 100
//  146 
//  147 /* ------------------------------------------------------------------------------------------------
//  148  *                                       Local Variables
//  149  * ------------------------------------------------------------------------------------------------
//  150  */
//  151 
//  152 #if defined UBL_GPIO_USE

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA16
//  153 static __no_init volatile uint8 *pForcePort;
??pForcePort:
        DS 2

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//  154 static __no_init uint8 forcePin;
??forcePin:
        DS 1
//  155 #endif

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA32
//  156 static __no_init uint32 stStart, stDelay;
??stStart:
        DS 4

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA32
??stDelay:
        DS 4
//  157 
//  158 #if UBL_SECURE
//  159 // Flag when built with UBL_SIGNER=TRUE to encrypt the read back.
//  160 static bool signMode;
//  161 #endif
//  162 
//  163 /* ------------------------------------------------------------------------------------------------
//  164  *                                       Local Functions
//  165  * ------------------------------------------------------------------------------------------------
//  166  */
//  167 
//  168 #if UBL_SECURE
//  169 static uint8 aesCheckCtrl(void *pBuf);
//  170 static void  aesLoadKey(void);
//  171 static void  aesInitSig(void);
//  172 #endif
//  173 
//  174 static bool cntDnForcedDecr(void);
//  175 #if defined UBL_GPIO_USE
//  176 static bool gpioInit(void);
//  177 #endif
//  178 static void vddWait(void);
//  179 
//  180 /**************************************************************************************************
//  181  * @fn          ublAesAuth
//  182  *
//  183  * @brief       Run the AES CRC-MAC authentication calculation over the RC image according to the
//  184  *              AES Control Block parameters and update the control block accordingly.
//  185  *              Just set CRC shadow equal to CRC when no valid security key built into the UBL.
//  186  *
//  187  * input parameters
//  188  *
//  189  * None.
//  190  *
//  191  * output parameters
//  192  *
//  193  * None.
//  194  *
//  195  * @return      TRUE or FALSE whether the AES signature of the image in flash is valid.
//  196  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  197 uint8 ublAesAuth(void)
ublAesAuth:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function ublAesAuth
        CODE
//  198 {
        FUNCALL ublAesAuth, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublAesAuth, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  199 #if UBL_SECURE
//  200   uint8 pgCnt = 0;
//  201   uint8 sigBuf[KEY_BLENGTH];
//  202 
//  203   aes_ctrl_blk_t ctrlBlk;
//  204   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  205 
//  206   aesInitSig();
//  207 
//  208   for (uint8 pgNum = UBL_PAGE_FIRST; pgNum <= UBL_PAGE_LAST; pgNum++)
//  209   {
//  210     if (!GET_BIT(ublMD.writeEn, pgNum))
//  211     {
//  212       continue;
//  213     }
//  214 
//  215     pgCnt++;
//  216 
//  217     HalFlashRead(pgNum, 0, pgBuf, HAL_FLASH_PAGE_SIZE);
//  218 
//  219     for (uint16 oset = 0; oset < HAL_FLASH_PAGE_SIZE; )
//  220     {
//  221       if ((pgCnt == 1) && (oset == 0))
//  222       {
//  223         oset += KEY_BLENGTH;  // Must not include the signature bytes in the signature calculation.
//  224       }
//  225       else if ((pgCnt == ctrlBlk.imageLen) && (oset == (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH)))
//  226       {
//  227         break;  // Need to change mode to CBC-MAC for the last block.
//  228       }
//  229 
//  230       ENCCS |= 0x01;
//  231       for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  232       {
//  233         ENCDI = pgBuf[oset++];
//  234       }
//  235       while ((ENCCS & BV(3)) == 0);
//  236     }
//  237 
//  238     if (pgCnt >= ctrlBlk.imageLen)
//  239     {
//  240       break;
//  241     }
//  242   }
//  243 
//  244   ENCCS = CBC | AES_ENCRYPT | 0x01;  // Switch to CBC mode for the last block.
//  245 
//  246   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  247   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  248   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  249 
//  250   for (uint16 oset = (HAL_FLASH_PAGE_SIZE - KEY_BLENGTH); oset < HAL_FLASH_PAGE_SIZE; oset++)
//  251   {
//  252     ENCDI = pgBuf[oset];
//  253   }
//  254   HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out below.
//  255 
//  256   // CBC-MAC generates output on the last block.
//  257   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  258   {
//  259     sigBuf[cnt] = ENCDO;
//  260   }
//  261 
//  262   if (ctrlBlk.allowSignCmd != 0)  // If requested to sign this image.
//  263   {
//  264     ctrlBlk.allowSignCmd = 0;
//  265     (void)memcpy(ctrlBlk.signature, sigBuf, KEY_BLENGTH);
//  266     UBL_NVM_SET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  267     UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  268   }
//  269 
//  270 #if UBL_SIGNER
//  271   signMode = TRUE;  // Now the Signer should encrypt the read back.
//  272 #else  // A signer must always return FALSE so that usb_msd.c does not save the file name to flash.
//  273   if (memcmp(ctrlBlk.signature, sigBuf, KEY_BLENGTH))
//  274 #endif
//  275   {
//  276     return FALSE;
//  277   }
//  278 #endif
//  279 
//  280   HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x4
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x64
        MOV     R3,#0x6
        MOV     R1,#0x1
        LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
//  281 
//  282   ublMD.crcShdw = ublMD.crcRC;
        MOV     DPTR,#ublMD
        LCALL   ??Subroutine28_0 & 0xFFFF
??CrossCallReturnLabel_36:
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  283   ublMD.crcRC = UBL_CRC_ERASED;  // Do not write zero to the same bits more than twice.
        MOV     DPTR,#ublMD
        MOV     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  284   HalFlashWrite(UBL_META_DATA_ADDR_WR, (uint8 *)&ublMD.crcRC, 1);
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0,#0x1
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x59
        MOV     R3,#0x3
        LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
//  285 
//  286   return TRUE;
        MOV     R1,#0x1
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock3
//  287 }
//  288 
//  289 /**************************************************************************************************
//  290  * @fn          ublAesCrypt
//  291  *
//  292  * @brief       UBL AES encryption/decyption for the low-level transport driver.
//  293  *              Just return when no valid security key built into the UBL.
//  294  *
//  295  * input parameters
//  296  *
//  297  * @param       pgNum - HAL Flash page number corresponding to the pgBuf.
//  298  * @param       pgBuf - Pointer to the page buffer to crypt in place.
//  299  *
//  300  * output parameters
//  301  *
//  302  * @param       pgBuf - Pointer to the page buffer of crypted bytes.
//  303  *
//  304  * @return      TRUE or FALSE whether the AES image page is valid (i.e. the ctrl block on 1st page).
//  305  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  306 uint8 ublAesCrypt(uint8 pgNum, uint8 *pgBuf)
ublAesCrypt:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function ublAesCrypt
        CODE
//  307 {
        ; Saved register size: 0
        ; Auto size: 0
//  308 #if UBL_SECURE
//  309   if (!UBL_SIGNER || signMode)
//  310   {
//  311     // A0: L-encoding of L-1 = 2-1 = 1; starting 2-byte CTR at 1.
//  312     uint8 ivNonce[KEY_BLENGTH] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
//  313     uint8 *pBuf = pgBuf;
//  314 
//  315     ENCCS = CTR | AES_LOAD_IV | 0x01;
//  316 
//  317     // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  318     // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  319     ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  320 
//  321     for (uint8 idx = 0; idx < KEY_BLENGTH; idx++)
//  322     {
//  323       ENCDI = ivNonce[idx];
//  324     }
//  325     while ((ENCCS & BV(3)) == 0);
//  326 
//  327     for (uint8 cnt = 0; cnt < (HAL_FLASH_PAGE_SIZE / KEY_BLENGTH); cnt++)
//  328     {
//  329       ENCCS = CTR | AES_ENCRYPT | 0x01;
//  330 
//  331       // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  332       // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  333       ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  334 
//  335       for (uint8 blk = 0; blk < 4; blk++)
//  336       {
//  337         for (uint8 idx = 0; idx < 4; idx++)
//  338         {
//  339           ENCDI = pBuf[idx];
//  340         }
//  341 
//  342         HAL_AES_DELAY();  // Delay required for non-DMA AES as RDY bit only goes hi after read out.
//  343 
//  344         for (uint8 idx = 0; idx < 4; idx++)
//  345         {
//  346           pBuf[idx] = ENCDO;
//  347         }
//  348 
//  349         pBuf += 4;
//  350       }
//  351     }
//  352 
//  353     if ((pgNum == UBL_PAGE_FIRST) && !aesCheckCtrl(pgBuf))
//  354     {
//  355       return FALSE;
//  356     }
//  357   }
//  358 #else
//  359   (void)pgNum;
//  360   (void)pgBuf;
//  361 #endif
//  362 
//  363   return TRUE;
        MOV     R1,#0x1
        LJMP    ?BRET
          CFI EndBlock cfiBlock4
//  364 }
//  365 
//  366 /**************************************************************************************************
//  367  * @fn          ublCfg
//  368  *
//  369  * @brief       Configure according to the received meta-data file if it checks out.
//  370  *
//  371  * input parameters
//  372  *
//  373  * @param       pMD - Pointer to the received meta-data file.
//  374  *
//  375  * output parameters
//  376  *
//  377  * None.
//  378  *
//  379  * @return      TRUE if the cfg file is acceptable; FALSE otherwise.
//  380  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  381 bool ublCfg(ublMetaData_t *pMD)
ublCfg:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function ublCfg
        CODE
//  382 {
        FUNCALL ublCfg, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, ublMassErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublCfg, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  383   // Thwart an attempt to break-in by an exhaustive Security Key trial-and-error.
//  384   if (!UBL_UNLOCKED && (memcmp(&ublMD.secKey, &pMD->secKey, sizeof(ublMD.secKey)) != 0))
        MOV     DPTR,#ublMD + 99
        MOVX    A,@DPTR
        JZ      ??ublCfg_0
        ; Setup parameters for call to function memcmp
        MOV     ?V0,#0x20
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R6
        ADD     A,#0x8
        MOV     R4,A
        CLR     A
        ADDC    A,R7
        MOV     R5,A
        MOV     R2,#(ublMD + 8) & 0xff
        MOV     R3,#((ublMD + 8) >> 8) & 0xff
        LCALL   ??memcmp?relay       ; Banked call to: memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JZ      ??ublCfg_0
//  385   {
//  386     if (ublMD.cntDnSecKey == 0)
        MOV     DPTR,#ublMD + 96
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x1
        JNZ     ??ublCfg_1
//  387     {
//  388       ublMassErase(TRUE);  // Force the erase of all pages outside of the UBL image.
        ; Setup parameters for call to function ublMassErase
        LCALL   ??ublMassErase?relay ; Banked call to: ublMassErase
//  389       HAL_SYSTEM_RESET();
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??ublCfg_2:
        SJMP    ??ublCfg_2
//  390     }
//  391     else
//  392     {
//  393       uint8 mask = 0x01;
//  394 
//  395       while ((mask & ublMD.cntDnSecKey) == 0)
//  396       {
//  397         mask <<= 1;
??ublCfg_3:
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     R1,A
//  398       }
??ublCfg_1:
        MOV     A,R1
        ANL     A,R0
        JZ      ??ublCfg_3
//  399       ublMD.cntDnSecKey ^= mask;
        MOVX    A,@DPTR
        XRL     A,R1
        MOVX    @DPTR,A
//  400 
//  401       // This will write zero to exactly one bit, so no bit is written to zero twice.
//  402       uint8 secKeyAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
        MOV     DPTR,#`?<Constant {255, 255, 255, 255}>`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x4
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  403       secKeyAndPad[0] ^= mask;
        LCALL   ?Subroutine12 & 0xFFFF
//  404       HalFlashWrite(UBL_CNTDN_SECKEY_ADDR, secKeyAndPad, 1);
//  405     }
//  406   }
??CrossCallReturnLabel_9:
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#-0x41
        MOV     R3,#0x3
        LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  407   else
//  408   {
//  409     UBL_UNLOCK();
//  410     (void)memcpy(&ublMD.chkMD, &pMD->chkMD, UBL_MD_CHKLEN);
//  411     ublMD.crcShdw = UBL_CRC_ZEROED;  // Receiving a "cfg" file is a de facto force of UBL mode.
//  412     return TRUE;
//  413   }
//  414 
//  415   return FALSE;
        MOV     R1,#0x0
        SJMP    ??ublCfg_4
??ublCfg_0:
        MOV     DPTR,#ublMD + 99
        CLR     A
        MOVX    @DPTR,A
        ; Setup parameters for call to function memcpy
        MOV     ?V0,#0x58
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R6
        ADD     A,#0x4
        MOV     R4,A
        CLR     A
        ADDC    A,R7
        MOV     R5,A
        MOV     R2,#(ublMD + 4) & 0xff
        MOV     R3,#((ublMD + 4) >> 8) & 0xff
        LCALL   ??memcpy?relay       ; Banked call to: memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        MOV     R1,#0x1
??ublCfg_4:
        MOV     A,#0x4
          CFI EndBlock cfiBlock5
        REQUIRE ?Subroutine5
        REQUIRE _A_IEN0
        REQUIRE WDCTL
        ; // Fall through to label ?Subroutine5
//  416 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI Invalid
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Valid
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock6
//  417 
//  418 /**************************************************************************************************
//  419  * @fn          ublExec
//  420  *
//  421  * @brief       UBL executive loop for polling and managing environment.
//  422  *
//  423  * input parameters
//  424  *
//  425  * None.
//  426  *
//  427  * output parameters
//  428  *
//  429  * None.
//  430  *
//  431  * @return      None.
//  432  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  433 void ublExec(void)
ublExec:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function ublExec
        CODE
//  434 {
        FUNCALL ublExec, usb_msd_poll
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublExec, usb_msd_uninit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublExec, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        SJMP    ??ublExec_0
//  435   while (1)
//  436   {
//  437     // No continual waits for VDD_MIN_NV - Vdd is assumed to be stable on a USB-powered device.
//  438     //vddWait();
//  439 
//  440     if (usb_msd_poll() == TRUE)  // TRUE == "Eject".
//  441     {
//  442       break;
//  443     }
//  444 
//  445     if (UBL_RC_VALID && (ublMD.dlyJmp != 0))
//  446     {
//  447 #if defined UBL_GPIO_USE
//  448       if (!GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) &&
//  449           (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0)))
//  450       {
//  451         ublMD.crcShdw = UBL_CRC_ZEROED;
??ublExec_1:
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  452       }
??ublExec_0:
        ; Setup parameters for call to function usb_msd_poll
        LCALL   ??usb_msd_poll?relay ; Banked call to: usb_msd_poll
        MOV     A,R1
        XRL     A,#0x1
        MOV     DPTR,#ublMD
        JNZ     $+5
        LJMP    ??ublExec_2 & 0xFFFF
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_4:
        JNZ     ??ublExec_3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublExec_3:
        JNZ     ??ublExec_0
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublExec_4
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublExec_4:
        JZ      ??ublExec_0
        MOV     A,R0
        ORL     A,R1
        JZ      ??ublExec_0
        MOV     DPTR,#ublMD + 6
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_49:
        JZ      ??ublExec_0
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??ublExec_5
        MOV     C,0xE0 /* A   */.1
        JNC     ??ublExec_6
        SETB    B.0
        SJMP    ??ublExec_7
??ublExec_6:
        CLR     B.0
??ublExec_7:
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     R2,A
        MOV     ?V0,#0x1
        MOV     ?V1,#0x0
        MOV     DPTR,#??forcePin
        MOVX    A,@DPTR
        MOV     R0,#?V0
        LCALL   ?S_SHL
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_16:
        ANL     A,?V0
        JZ      ??ublExec_8
        SETB    B.0
        SJMP    ??ublExec_9
??ublExec_8:
        CLR     B.0
??ublExec_9:
        MOV     A,R2
        MOV     C,0xE0 /* A   */.0
        JB      B.0,??ublExec_10
        CPL     C
??ublExec_10:
        JC      ??ublExec_1
//  453       else
//  454 #endif
//  455       {
//  456         uint32 stDelta;
//  457         UBL_READ_ST(stDelta);  // Get the free-running count of 30.5 usec timer ticks.
??ublExec_5:
        MOV     A,0x95
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        XRL     A,0x95
        JNZ     ??ublExec_5
        MOV     A,0x96
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,0x97
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
//  458         stDelta -= stStart;  // Calculate the elapsed ticks of the free-running timer.
        MOV     DPTR,#??stStart
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V0
        LCALL   ?L_SUB_FROM_X
//  459         ((uint8 *)&stDelta)[3] = 0;  // Adjust for a carry on the 24-bit ST counter.
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
//  460 
//  461         if (stDelta > stDelay)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R0,#?V0
        LCALL   ?L_MOV_X
        MOV     DPTR,#??stDelay
        MOV     R0,#?V0
        LCALL   ?UL_GT_X
        JC      $+5
        LJMP    ??ublExec_0 & 0xFFFF
        SJMP    ??ublExec_11
//  462         {
//  463           break;
//  464         }
//  465       }
//  466     }
//  467   }
//  468 
//  469   if (UBL_RC_VALID)
??ublExec_2:
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_5:
        JNZ     ??ublExec_12
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublExec_12:
        JNZ     ??ublExec_13
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublExec_14
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublExec_14:
        JZ      ??ublExec_13
        MOV     A,R0
        ORL     A,R1
        JZ      ??ublExec_13
//  470   {
//  471     usb_msd_uninit();
??ublExec_11:
        ; Setup parameters for call to function usb_msd_uninit
        LCALL   ??usb_msd_uninit?relay; Banked call to: usb_msd_uninit
//  472     ublJump();
        ; Setup parameters for call to function ublJump
        LCALL   ??ublJump?relay      ; Banked call to: ublJump
//  473   }
//  474 }
??ublExec_13:
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ?Subroutine0 & 0xFFFF
          CFI EndBlock cfiBlock7
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2
//  475 
//  476 /**************************************************************************************************
//  477  * @fn          ublInit
//  478  *
//  479  * @brief       UBL environment initialization in preparation for running.
//  480  *
//  481  * input parameters
//  482  *
//  483  * None.
//  484  *
//  485  * output parameters
//  486  *
//  487  * None.
//  488  *
//  489  * @return      None.
//  490  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  491 void ublInit(void)
ublInit:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function ublInit
        CODE
//  492 {
        FUNCALL ublInit, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ??gpioInit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ublInit, usb_msd_init
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  493   HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD, sizeof(ublMetaData_t));
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x64
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x64
        MOV     R3,#0x6
        MOV     R1,#0x1
        LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  494 
//  495   // If the RC image area is erased or the Application doesn't care about security, unlock the UBL.
//  496   if (memcmp(ublMD.secKey, unlockedSecKey, sizeof(unlockedSecKey)) == 0)
        ; Setup parameters for call to function memcmp
        MOV     ?V0,#0x20
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#??unlockedSecKey & 0xff
        MOV     R5,#(??unlockedSecKey >> 8) & 0xff
        MOV     R2,#(ublMD + 8) & 0xff
        MOV     R3,#((ublMD + 8) >> 8) & 0xff
        LCALL   ??memcmp?relay       ; Banked call to: memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JNZ     ??ublInit_0
//  497   {
//  498     UBL_UNLOCK();
        MOV     DPTR,#ublMD + 99
        CLR     A
        MOVX    @DPTR,A
//  499   }
//  500 
//  501   if (UBL_RC_VALID)
??ublInit_0:
        MOV     DPTR,#ublMD
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_6:
        JNZ     ??ublInit_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??ublInit_1:
        JZ      $+5
        LJMP    ??ublInit_2 & 0xFFFF
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??ublInit_3
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??ublInit_3:
        JNZ     $+5
        LJMP    ??ublInit_2 & 0xFFFF
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??ublInit_2 & 0xFFFF
//  502   {
//  503     if ((ublMD.cntDnForced == 0) || (cntDnForcedDecr() == FALSE))
        MOV     DPTR,#ublMD + 92
        MOVX    A,@DPTR
        MOV     R0,A
        JZ      ??ublInit_4
        MOV     R1,#0x1
        SJMP    ??ublInit_5
??ublInit_6:
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     R1,A
??ublInit_5:
        MOV     A,R1
        ANL     A,R0
        JZ      ??ublInit_6
        MOVX    A,@DPTR
        XRL     A,R1
        MOVX    @DPTR,A
        JNZ     ??ublInit_7
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        SJMP    ??ublInit_8
??ublInit_7:
        MOV     DPTR,#`?<Constant {255, 255, 255, 255}>_1`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x4
        LCALL   ?MOVE_LONG8_XDATA_XDATA
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_10:
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP102_8
        MOV     R2,#-0x42
        MOV     R3,#0x3
        LCALL   ??HalFlashWrite?relay; Banked call to: HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  504     {
//  505 #if defined UBL_GPIO_USE
//  506       if (GET_BIT(ublMD.cfgDiscs+0, gpioUseNot) || (gpioInit() == FALSE))
??ublInit_4:
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??ublInit_9
        ; Setup parameters for call to function gpioInit
        LCALL   ??gpioInit?relay     ; Banked call to: gpioInit
        MOV     A,R1
        JNZ     ??ublInit_2
//  507 #endif
//  508       {
//  509         if (ublMD.dlyJmp == 0)
??ublInit_9:
        MOV     DPTR,#ublMD + 6
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_12:
        ORL     A,?V1
        JNZ     ??ublInit_10
//  510         {
//  511           ublJump();
        ; Setup parameters for call to function ublJump
        LCALL   ??ublJump?relay      ; Banked call to: ublJump
        SJMP    ??ublInit_2
//  512         }
//  513         else
//  514         {
//  515           stDelay = (ublMD.dlyJmp * 4096UL) / 125;
??ublInit_10:
        CLR     A
        MOV     ?V2,A
        MOV     ?V3,A
        MOV     A,#0xc
        MOV     R0,#?V0
        LCALL   ?L_SHL
        MOV     DPTR,#__Constant_7d
        MOV     R0,#?V4
        LCALL   ?L_MOV_X
        MOV     R0,#?V0
        MOV     R1,#?V4
        LCALL   ?UL_DIV_MOD
        MOV     DPTR,#??stDelay
        MOV     R0,#?V0
        LCALL   ?L_MOV_TO_X
//  516           UBL_READ_ST(stStart);
??ublInit_11:
        MOV     A,0x95
        MOV     DPTR,#??stStart
        MOVX    @DPTR,A
        XRL     A,0x95
        JNZ     ??ublInit_11
        MOV     A,0x96
        INC     DPTR
        MOVX    @DPTR,A
        MOV     A,0x97
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??ublInit_8:
        MOVX    @DPTR,A
//  517         }
//  518       }
//  519     }
//  520   }
//  521 
//  522   vddWait();  // Stricter wait then in main, looking for safe Vdd for writing flash.
??ublInit_2:
        MOV     R0,#0x10
??ublInit_12:
        MOV     0xb6,#0xf
??ublInit_13:
        MOV     A,0xb4
        MOV     C,0xE0 /* A   */.7
        JNC     ??ublInit_13
        MOV     A,0xbb
        CLR     C
        SUBB    A,#0x4e
        JC      ??ublInit_12
        DEC     R0
        MOV     A,R0
        JNZ     ??ublInit_12
//  523 
//  524 #if UBL_SECURE
//  525   aesLoadKey();
//  526 
//  527   aes_ctrl_blk_t ctrlBlk;
//  528   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  529 
//  530   if ((ctrlBlk.allowSignCmd != 0) && (ctrlBlk.imageLen != 0xFF)) // If requested to sign this image.
//  531   {
//  532     // Signing after checking UBL_RC_VALID ensures run as MSD again so encrypted image can be read.
//  533     (void)ublAesAuth();
//  534   }
//  535 
//  536 #if UBL_SIGNER  // A signer must allow image read back of what was written.
//  537   for (uint8 idx = 0; idx < 16; idx++)
//  538   {
//  539     ublMD.readLock[idx] = ublMD.writeEn[idx] ^ 0xFF;
//  540   }
//  541 #endif
//  542 #endif
//  543 
//  544   usb_msd_init();  // Initialize USB-MSD as late as possible for time limits after enabling D+ line.
        ; Setup parameters for call to function usb_msd_init
        LCALL   ??usb_msd_init?relay ; Banked call to: usb_msd_init
//  545 }
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock8
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2
        REQUIRE ADCCON3
        REQUIRE ADCCON1
        REQUIRE ADCH

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine13:
          CFI Block cfiCond9 Using cfiCommon0
          CFI Function HalFlashWrite
          CFI Conditional ??CrossCallReturnLabel_11
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function ublInit
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond10) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond10) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond10) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond10) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond10) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond10) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond10) CFA_SP SP+-2
          CFI (cfiCond10) CFA_XSP16 add(XSP16, 20)
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     A,?V0
        RET
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine12:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function ublCfg
          CFI Conditional ??CrossCallReturnLabel_9
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function ublInit
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond13) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond13) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond13) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond13) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond13) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond13) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond13) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond13) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond13) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond13) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond13) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond13) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond13) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond13) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond13) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond13) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond13) CFA_SP SP+-2
          CFI (cfiCond13) CFA_XSP16 add(XSP16, 20)
          CFI Block cfiPicker14 Using cfiCommon1
          CFI (cfiPicker14) NoFunction
          CFI (cfiPicker14) Picker
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R1
        MOVX    @DPTR,A
        ; Setup parameters for call to function HalFlashWrite
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0,#0x1
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        RET
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiPicker14

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
          CFI Block cfiCond15 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_4
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond16 Using cfiCommon0
          CFI (cfiCond16) Function ublExec
          CFI (cfiCond16) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond16) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond16) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond16) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond16) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond16) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond16) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond16) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond16) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond16) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond16) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond16) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond16) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond16) CFA_SP SP+-2
          CFI (cfiCond16) CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond17 Using cfiCommon0
          CFI (cfiCond17) Function ublInit
          CFI (cfiCond17) Conditional ??CrossCallReturnLabel_6
          CFI (cfiCond17) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond17) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond17) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond17) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond17) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond17) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond17) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond17) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond17) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond17) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond17) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond17) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond17) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond17) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond17) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond17) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond17) CFA_SP SP+-2
          CFI (cfiCond17) CFA_XSP16 add(XSP16, 20)
          CFI Block cfiPicker18 Using cfiCommon1
          CFI (cfiPicker18) NoFunction
          CFI (cfiPicker18) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_62:
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        RET
          CFI EndBlock cfiCond15
          CFI EndBlock cfiCond16
          CFI EndBlock cfiCond17
          CFI EndBlock cfiPicker18
//  546 
//  547 /**************************************************************************************************
//  548  * @fn          ublJump
//  549  *
//  550  * @brief       Execute a simple long jump from non-banked UBL code to non-banked RC code space.
//  551  *
//  552  * input parameters
//  553  *
//  554  * None.
//  555  *
//  556  * output parameters
//  557  *
//  558  * None.
//  559  *
//  560  * @return      None.
//  561  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  562 void ublJump(void)
ublJump:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function ublJump
        CODE
//  563 {
        ; Saved register size: 0
        ; Auto size: 0
//  564   asm("LJMP 0x820\n");  // Immediate jump to run-code.
        LJMP 0x820
//  565   HAL_SYSTEM_RESET();
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??ublJump_0:
        SJMP    ??ublJump_0
          CFI EndBlock cfiBlock19
        REQUIRE _A_IEN0
        REQUIRE WDCTL
//  566 }
//  567 
//  568 /**************************************************************************************************
//  569  * @fn          ublMassErase
//  570  *
//  571  * @brief       Erase all pages enabled for mass-erase (not including UBL pages or lock bits page).
//  572  *
//  573  * input parameters
//  574  *
//  575  * @param       eraseAll - Flag to override the 'eraseEn' bits of the Meta Data.
//  576  *
//  577  * output parameters
//  578  *
//  579  * None.
//  580  *
//  581  * @return      None.
//  582  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  583 void ublMassErase(bool eraseAll)
ublMassErase:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function ublMassErase
        CODE
//  584 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  585   for (uint8 pg = UBL_RC_IMG_PG_BEG+1; pg <= UBL_PAGE_LAST; pg++)
        MOV     R0,#0x2
//  586   {
//  587     if (eraseAll || GET_BIT(ublMD.eraseEn, pg))
??ublMassErase_0:
        MOV     A,R1
        JNZ     ??ublMassErase_1
        MOV     A,R0
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R2,A
        MOV     A,#(ublMD + 40) & 0xff
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,#((ublMD + 40) >> 8) & 0xff
        MOV     DPH,A
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-6
        MOV     A,#0x7
        ANL     A,R0
        MOV     R2,A
        POP     A
          CFI CFA_SP SP+-5
        CJNE    R2,#0x0,??ublMassErase_2
        SJMP    ??ublMassErase_3
??ublMassErase_2:
        CLR     C
        RRC     A
        DJNZ    R2,??ublMassErase_2
??ublMassErase_3:
        MOV     C,0xE0 /* A   */.0
        JNC     ??ublMassErase_4
//  588     {
//  589       FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
??ublMassErase_1:
        MOV     A,R0
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        MOVX    @DPTR,A
//  590       FCTL |= 0x01;
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
//  591     }
//  592   }
??ublMassErase_4:
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x78
        JC      ??ublMassErase_0
//  593 
//  594   // Now erase the page with the filename.
//  595   FADDRH = UBL_RC_IMG_PG_BEG * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
        MOV     DPTR,#0x6272
        MOV     A,#0x2
        LJMP    ?Subroutine2 & 0xFFFF
          CFI EndBlock cfiBlock20
//  596   FCTL |= 0x01;
//  597 }
//  598 
//  599 #if UBL_SECURE
//  600 /**************************************************************************************************
//  601  * @fn          aesCheckCtrl
//  602  *
//  603  * @brief       Check validity of a AES Control Block before writing it to flash.
//  604  *
//  605  * input parameters
//  606  *
//  607  * @param       pBuf - Pointer to the buffer containing the control block.
//  608  *
//  609  * output parameters
//  610  *
//  611  * None.
//  612  *
//  613  * @return      TRUE or FALSE for control block valid.
//  614  */
//  615 static uint8 aesCheckCtrl(void *pBuf)
//  616 {
//  617   uint8 sigBuf[KEY_BLENGTH] =
//  618    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//  619   aes_ctrl_blk_t *pCtl = (aes_ctrl_blk_t *)pBuf;
//  620 
//  621 #if UBL_SIGNER
//  622   if ( memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
//  623           || (pCtl->imageLen == 0)
//  624           || (pCtl->imageLen > UBL_PAGE_LAST)
//  625           || (pCtl->allowSignCmd == 0))
//  626 #else
//  627   if (!memcmp(pCtl->signature, sigBuf, sizeof(sigBuf))
//  628           || (pCtl->imageLen == 0)
//  629           || (pCtl->imageLen > UBL_PAGE_LAST)
//  630           || (pCtl->allowSignCmd != 0))
//  631 #endif
//  632   {
//  633     return FALSE;
//  634   }
//  635 
//  636   return TRUE;
//  637 }
//  638 
//  639 /**************************************************************************************************
//  640  * @fn          aesLoadKey
//  641  *
//  642  * @brief       Load the shared secret key into the AES for operations.
//  643  *
//  644  * input parameters
//  645  *
//  646  * None.
//  647  *
//  648  * output parameters
//  649  *
//  650  * None.
//  651  *
//  652  * @return      None.
//  653  */
//  654 static void aesLoadKey(void)
//  655 {
//  656   // Read the security key from flash 1 byte at a time to thwart an interrupt & read XDATA attack.
//  657   uint8 *keyPtr = (uint8 *)aesKey;
//  658 
//  659   ENCCS = ECB | AES_LOAD_KEY | 0x01;
//  660 
//  661   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  662   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  663   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  664 
//  665   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  666   {
//  667     ENCDI = *keyPtr++;
//  668   }
//  669 }
//  670 
//  671 /**************************************************************************************************
//  672  * @fn          aesInitSig
//  673  *
//  674  * @brief       Initialize the AES for signature calculation.
//  675  *
//  676  * input parameters
//  677  *
//  678  * None.
//  679  *
//  680  * output parameters
//  681  *
//  682  * None.
//  683  *
//  684  * @return      None.
//  685  */
//  686 static void aesInitSig(void)
//  687 {
//  688   aes_ctrl_blk_t ctrlBlk;
//  689   UBL_NVM_GET(UBL_ADDR_CTRL, &ctrlBlk, sizeof(aes_ctrl_blk_t));
//  690 
//  691   ENCCS = CBC_MAC | AES_LOAD_IV | 0x01;
//  692 
//  693   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  694   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  695   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  696 
//  697   for (uint8 cnt = 0; cnt < KEY_BLENGTH; cnt++)
//  698   {
//  699     ENCDI = 0;
//  700   }
//  701 
//  702   ENCCS = CBC_MAC | AES_ENCRYPT | 0x01;
//  703 
//  704   // 'while ((ENCCS & BV(3)) == 0)' was seen to hang without #pragma optimize=none.
//  705   // So proactively adding this wait after every 'ENCCS = ' which empirically seems to work.
//  706   ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP; ASM_NOP;
//  707 
//  708   ENCDI = 0x3A;  // B0 Flag: Res=0, A_Data=0, (M-2)/2=7, (L-1)=2.
//  709 
//  710   ENCDI = LO_UINT16(ctrlBlk.spare[0]);
//  711   ENCDI = HI_UINT16(ctrlBlk.spare[0]);
//  712   for (uint8 idx = 0; idx < 10; idx++)
//  713   {
//  714     ENCDI = ctrlBlk.nonce10[idx];
//  715   }
//  716 
//  717   // Image length in 3 bytes, MSB to LSB order - the Signature bytes are not to be included.
//  718   uint32 imageLen = 2048UL * ctrlBlk.imageLen - KEY_BLENGTH;
//  719   ENCDI = ((uint8 *)&imageLen)[2];
//  720   ENCDI = ((uint8 *)&imageLen)[1];
//  721   ENCDI = ((uint8 *)&imageLen)[0];
//  722 
//  723   while ((ENCCS & BV(3)) == 0);
//  724 }
//  725 #endif
//  726 
//  727 /**************************************************************************************************
//  728  * @fn          cntDnForcedDecr
//  729  *
//  730  * @brief       Decrement the cntDnForced.
//  731  *
//  732  * input parameters
//  733  *
//  734  * None.
//  735  *
//  736  * output parameters
//  737  *
//  738  * None.
//  739  *
//  740  * @return      TRUE if the dlyJmp decrements to zero; FALSE otherwise.
//  741  */
//  742 static bool cntDnForcedDecr(void)
//  743 {
//  744   uint8 mask = 0x01;
//  745 
//  746   while ((mask & ublMD.cntDnForced) == 0)
//  747   {
//  748     mask <<= 1;
//  749   }
//  750   ublMD.cntDnForced ^= mask;
//  751 
//  752   if (ublMD.cntDnForced == 0)
//  753   {
//  754     // Don't write the zero to flash in case of another cold-boot before re-programming, just
//  755     // force boot now by faking the CRC-shdw as zeroed.
//  756     ublMD.crcShdw = UBL_CRC_ZEROED;  // No need to zero crcShdw in flash, this will always run.
//  757     return TRUE;
//  758   }
//  759   else
//  760   {
//  761     // This will write zero to exactly one bit, so no bit is written to zero twice.
//  762     uint8 forcedAndPad[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
//  763     forcedAndPad[0] ^= mask;
//  764     HalFlashWrite(UBL_CNTDN_FORCED_ADDR, forcedAndPad, 1);
//  765     return FALSE;
//  766   }
//  767 }
//  768 
//  769 #if defined UBL_GPIO_USE
//  770 /**************************************************************************************************
//  771  * @fn          gpioInit
//  772  *
//  773  * @brief       Initialize the generic GPIO force configuration.
//  774  *
//  775  * input parameters
//  776  *
//  777  * None.
//  778  *
//  779  * output parameters
//  780  *
//  781  * None.
//  782  *
//  783  * @return      TRUE if the GPIO is already forcing UBL mode; FALSE otherwise.
//  784  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  785 static bool gpioInit(void)
??gpioInit:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function ??gpioInit
        CODE
//  786 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  787   volatile uint8 *ptr;
//  788   uint8 port = ublMD.gpioPort / 8;
        MOV     DPTR,#ublMD + 89
        MOVX    A,@DPTR
        MOV     R0,A
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R1,A
//  789   uint8 pin = ublMD.gpioPort % 8;
        MOV     A,#0x7
        ANL     A,R0
        MOV     R4,A
//  790 
//  791   ptr = ((port == 0) ? &X_P0SEL : ((port == 1) ? &X_P1SEL : &X_P2SEL));
        MOV     A,R1
        JNZ     ??gpioInit_1
        MOV     R2,#-0xd
        SJMP    ??gpioInit_2
??gpioInit_1:
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??gpioInit_3
        MOV     R2,#-0xc
        SJMP    ??gpioInit_2
??gpioInit_3:
        MOV     R2,#-0xb
??gpioInit_2:
        MOV     R3,#0x70
//  792   *ptr &= ~BV(pin);
        MOV     A,R4
        MOV     R0,A
        MOV     A,#0x1
        CJNE    R0,#0x0,??gpioInit_4
        SJMP    ??gpioInit_5
??gpioInit_4:
        CLR     C
        RLC     A
        DJNZ    R0,??gpioInit_4
??gpioInit_5:
        MOV     R0,A
        CPL     A
        MOV     R5,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ANL     A,R5
        MOVX    @DPTR,A
//  793 
//  794   ptr = ((port == 0) ? &X_P0DIR : ((port == 1) ? &X_P1DIR : &X_P2DIR));
        MOV     A,R1
        JNZ     ??gpioInit_6
        MOV     R2,#-0x3
        SJMP    ??gpioInit_7
??gpioInit_6:
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??gpioInit_8
        MOV     R2,#-0x2
        SJMP    ??gpioInit_7
??gpioInit_8:
        MOV     R2,#-0x1
//  795   *ptr &= ~BV(pin);
??gpioInit_7:
        MOV     DPL,R2
        MOVX    A,@DPTR
        ANL     A,R5
        MOVX    @DPTR,A
//  796 
//  797   ptr = ((port == 0) ? &X_P0INP : ((port == 1) ? &X_P1INP : &X_P2INP));
        MOV     A,R1
        JNZ     ??gpioInit_9
        MOV     R2,#-0x71
        SJMP    ??gpioInit_10
??gpioInit_9:
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??gpioInit_11
        MOV     R2,#-0xa
        SJMP    ??gpioInit_10
??gpioInit_11:
        MOV     R2,#-0x9
//  798   if (GET_BIT(ublMD.cfgDiscs+0, gpioPullTri))     // If pulling.
??gpioInit_10:
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     ??gpioInit_12
//  799   {
//  800     if (GET_BIT(ublMD.cfgDiscs+0, gpioPullUpDn))  // If pulling up.
        MOV     ?V0,#0x1
        MOV     ?V1,#0x0
        MOV     A,#0x5
        ADD     A,R1
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,?V0
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        MOV     A,R0
        JNC     ??gpioInit_13
//  801     {
//  802       P2INP &= ~BV(port + 5);
        CPL     A
        ANL     0xf7,A
        SJMP    ??gpioInit_14
//  803     }
//  804     else                                          // If pulling down.
//  805     {
//  806       P2INP |= BV(port + 5); \ 
??gpioInit_13:
        ORL     0xf7,A
//  807     }
//  808     *ptr &= ~BV(pin);
??gpioInit_14:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ANL     A,R5
        SJMP    ??gpioInit_15
//  809   }
//  810   else                                            // Tri-state.
//  811   {
//  812     *ptr |=  BV(pin);
??gpioInit_12:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ORL     A,R0
??gpioInit_15:
        MOVX    @DPTR,A
//  813   }
//  814 
//  815   forcePin = pin;
        MOV     A,R4
        MOV     DPTR,#??forcePin
        MOVX    @DPTR,A
//  816   pForcePort = ((port == 0) ? &X_P0 : ((port == 1) ? &X_P1 : &X_P2));
        MOV     A,R1
        JNZ     ??gpioInit_16
        MOV     DPTR,#??pForcePort
        MOV     A,#-0x80
        SJMP    ??gpioInit_17
??gpioInit_16:
        MOV     A,#0x1
        XRL     A,R1
        MOV     DPTR,#??pForcePort
        JNZ     ??gpioInit_18
        MOV     A,#-0x70
        SJMP    ??gpioInit_17
??gpioInit_18:
        MOV     A,#-0x60
??gpioInit_17:
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x70
        MOVX    @DPTR,A
//  817 
//  818   if (GET_BIT(ublMD.cfgDiscs+0, gpioPolarity) == ((*pForcePort & BV(forcePin)) != 0))
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_17:
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#??forcePin
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
          CFI CFA_SP SP+0
        CJNE    R0,#0x0,??gpioInit_19
        SJMP    ??gpioInit_20
??gpioInit_19:
        CLR     C
        RRC     A
        DJNZ    R0,??gpioInit_19
??gpioInit_20:
        MOV     C,0xE0 /* A   */.0
        MOV     B.0,C
        MOV     DPTR,#ublMD + 88
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JB      B.0,??gpioInit_21
        CPL     C
??gpioInit_21:
        JNC     ??gpioInit_22
//  819   {
//  820     ublMD.crcShdw = UBL_CRC_ZEROED;
        MOV     DPTR,#ublMD + 2
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  821     return TRUE;
        MOV     R1,#0x1
        SJMP    ??gpioInit_23
//  822   }
//  823 
//  824   return FALSE;
??gpioInit_22:
        MOV     R1,#0x0
??gpioInit_23:
        SJMP    ??Subroutine27_0
          CFI EndBlock cfiBlock21
        REQUIRE P2INP
//  825 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine16:
          CFI Block cfiCond22 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_16
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond23 Using cfiCommon0
          CFI (cfiCond23) Function ??gpioInit
          CFI (cfiCond23) Conditional ??CrossCallReturnLabel_17
          CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond23) CFA_SP SP+-2
          CFI (cfiCond23) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiPicker24 Using cfiCommon1
          CFI (cfiPicker24) NoFunction
          CFI (cfiPicker24) Picker
        MOV     DPTR,#??pForcePort
        LCALL   ?Subroutine24 & 0xFFFF
??CrossCallReturnLabel_31:
        MOVX    A,@DPTR
        RET
          CFI EndBlock cfiCond22
          CFI EndBlock cfiCond23
          CFI EndBlock cfiPicker24
//  826 #endif
//  827 
//  828 /**************************************************************************************************
//  829  * @fn          vddWait
//  830  *
//  831  * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to erase/write flash.
//  832  *
//  833  * input parameters
//  834  *
//  835  * None.
//  836  *
//  837  * output parameters
//  838  *
//  839  * None.
//  840  *
//  841  * @return      None.
//  842  */
//  843 static void vddWait(void)
//  844 {
//  845   uint8 cnt = 16;
//  846 
//  847   do {
//  848     do {
//  849       ADCCON3 = 0x0F;
//  850       while (!(ADCCON1 & 0x80));
//  851     } while (ADCH < VDD_MIN_NV);
//  852   } while (--cnt);
//  853 }
//  854 
//  855 /**************************************************************************************************
//  856 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\app\ubl_main.c
//    1 /**************************************************************************************************
//    2   Filename:       ubl_main.c
//    3   Revised:        $Date: 2012-09-12 10:59:31 -0700 (Wed, 12 Sep 2012) $
//    4   Revision:       $Revision: 31516 $
//    5 
//    6   Description:
//    7 
//    8   This module implements the main functionality of a Universal Boot Loader for an 8051-based SOC
//    9   via the USB by MSD. The functionality is similar to ZStack OnBoard.c and hal_startup.c.
//   10 
//   11 
//   12   Copyright 2011-2012 Texas Instruments Incorporated. All rights reserved.
//   13 
//   14   IMPORTANT: Your use of this Software is limited to those specific rights
//   15   granted under the terms of a software license agreement between the user
//   16   who downloaded the software, his/her employer (which must be your employer)
//   17   and Texas Instruments Incorporated (the "License").  You may not use this
//   18   Software unless you agree to abide by the terms of the License. The License
//   19   limits your use, and you acknowledge, that the Software may not be modified,
//   20   copied or distributed unless embedded on a Texas Instruments microcontroller
//   21   or used solely and exclusively in conjunction with a Texas Instruments radio
//   22   frequency transceiver, which is integrated into your product.  Other than for
//   23   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   24   works of, modify, distribute, perform, display or sell this Software and/or
//   25   its documentation for any purpose.
//   26 
//   27   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   28   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   29   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   30   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   31   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   32   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   33   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   34   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   35   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   36   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   37   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   38 
//   39   Should you have any questions regarding your right to use this Software,
//   40   contact Texas Instruments Incorporated at www.TI.com.
//   41 **************************************************************************************************/
//   42 
//   43 /* ------------------------------------------------------------------------------------------------
//   44  *                                          Includes
//   45  * ------------------------------------------------------------------------------------------------
//   46  */
//   47 
//   48 #include "hal_board_cfg.h"
//   49 #include "hal_dma.h"
//   50 #include "hal_flash.h"
//   51 #include "ubl_app.h"
//   52 #include "ubl_exec.h"
//   53 #include "usb_interrupt.h"
//   54 
//   55 /* ------------------------------------------------------------------------------------------------
//   56  *                                       Global Variables
//   57  * ------------------------------------------------------------------------------------------------
//   58  */
//   59 

        RSEG XDATA_N:XDATA:REORDER:NOROOT(0)
        DATA8
//   60 __no_init halDMADesc_t dmaCh0;  // Needed by the HAL flash write.
dmaCh0:
        DS 8
//   61 
//   62 /* ------------------------------------------------------------------------------------------------
//   63  *                                       Local Functions
//   64  * ------------------------------------------------------------------------------------------------
//   65  */
//   66 
//   67 static void vddWait(void);
//   68 
//   69 // If the code model is banked, low_level_init must be declared
//   70 // __near_func elsa a ?BRET is performed
//   71 //
//   72 #if (__CODE_MODEL__ == 2)
//   73 __near_func __root char
//   74 #else
//   75 __root char
//   76 #endif
//   77 __low_level_init(void);
//   78 
//   79 /**************************************************************************************************
//   80  * @fn          __low_level_init
//   81  *
//   82  * @brief       Abort boot loader as soon as possible after a Watchdog reset with a valid RC image.
//   83  *              This function is called by the IAR start-up code before doing normal initialization
//   84  *              of the data segments.
//   85  *
//   86  * input parameters
//   87  *
//   88  * None.
//   89  *
//   90  * output parameters
//   91  *
//   92  * None.
//   93  *
//   94  * @return      0 - don't intialize data segments / 1 - do initialization.
//   95  */
//   96 #if (__CODE_MODEL__ == 2)

        RSEG NEAR_CODE:CODE:ROOT(0)
//   97 __near_func __root char
//   98 #else
//   99 __root char
//  100 #endif
//  101 __low_level_init(void)
__low_level_init:
          CFI Block cfiBlock25 Using cfiCommon2
          CFI Function __low_level_init
        CODE
        REQUIRE __low_level_init_call
//  102 {
        FUNCALL __low_level_init, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL __low_level_init, ublJump
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  103   // Map flash bank #7 into XDATA for access to "ROM mapped as data".
//  104   MEMCTR = (MEMCTR & 0xF8) | 0x07;
        ORL     0xc7,#0x7
//  105 
//  106   if (ResetWasWatchDog)
        MOV     A,0x9d
        ANL     A,#0x18
        XRL     A,#0x10
        JNZ     ??__low_level_init_0
//  107   {
//  108     // Read from Flash the minimum subset of ublMetaData_t necessary for UBL_RC_VALID().
//  109     HalFlashRead(UBL_META_DATA_PAGE, UBL_META_DATA_IDX, (uint8 *)&ublMD.crcRC, 4);
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0,#0x4
        MOV     ?V1,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 11)
        MOV     R4,#ublMD & 0xff
        MOV     R5,#(ublMD >> 8) & 0xff
        MOV     R2,#-0x64
        MOV     R3,#0x6
        MOV     R1,#0x1
        LCALL   ??HalFlashRead?relay ; Banked call to: HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 9)
//  110 
//  111     if (UBL_RC_VALID)
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??__low_level_init_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??__low_level_init_1:
        JNZ     ??__low_level_init_0
        MOV     DPTR,#ublMD
        MOVX    A,@DPTR
        CPL     A
        JNZ     ??__low_level_init_2
        INC     DPTR
        MOVX    A,@DPTR
        CPL     A
??__low_level_init_2:
        JZ      ??__low_level_init_0
        MOV     A,R0
        ORL     A,R1
        JZ      ??__low_level_init_0
//  112     {
//  113       ublJump();
        ; Setup parameters for call to function ublJump
        LCALL   ??ublJump?relay      ; Banked call to: ublJump
//  114     }
//  115   }
//  116 
//  117   vddWait();
??__low_level_init_0:
        MOV     R0,#0x10
??__low_level_init_3:
        MOV     0xb6,#0xf
??__low_level_init_4:
        MOV     A,0xb4
        MOV     C,0xE0 /* A   */.7
        JNC     ??__low_level_init_4
        MOV     A,0xbb
        CLR     C
        SUBB    A,#0x4a
        JC      ??__low_level_init_3
        DEC     R0
        MOV     A,R0
        JNZ     ??__low_level_init_3
//  118   HAL_BOARD_INIT();
        MOV     0xa8,#0x0
        MOV     0xb8,#0x0
        MOV     0x9a,#0x0
        MOV     0xc6,#-0x80
        MOV     DPTR,#0x6270
        MOV     A,#0x8
        MOVX    @DPTR,A
//  119 
//  120   // Choose if segment initialization should be done or not: 0 to omit seg_init; 1 to run seg_init.
//  121   return 1;
        MOV     R1,#0x1
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
          CFI EndBlock cfiBlock25
        REQUIRE MEMCTR
        REQUIRE SLEEPSTA
        REQUIRE _A_IEN0
        REQUIRE _A_IEN1
        REQUIRE IEN2
        REQUIRE CLKCONCMD
        REQUIRE ADCCON3
        REQUIRE ADCCON1
        REQUIRE ADCH
//  122 }

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
??usbdpData:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
??languageId:
        DATA8
        DB 4
        DB 3
        DB 9
        DB 4

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
??manufacturer:
        DB 36
        DB 3
        DB 84
        DB 0
        DB 101
        DB 0
        DB 120
        DB 0
        DB 97
        DB 0
        DB 115
        DB 0
        DB 32
        DB 0
        DB 73
        DB 0
        DB 110
        DB 0
        DB 115
        DB 0
        DB 116
        DB 0
        DB 114
        DB 0
        DB 117
        DB 0
        DB 109
        DB 0
        DB 101
        DB 0
        DB 110
        DB 0
        DB 116
        DB 0
        DB 115
        DB 0

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
??product:
        DB 36
        DB 3
        DB 84
        DB 0
        DB 73
        DB 0
        DB 32
        DB 0
        DB 67
        DB 0
        DB 67
        DB 0
        DB 50
        DB 0
        DB 53
        DB 0
        DB 51
        DB 0
        DB 49
        DB 0
        DB 32
        DB 0
        DB 85
        DB 0
        DB 83
        DB 0
        DB 66
        DB 0
        DB 32
        DB 0
        DB 77
        DB 0
        DB 83
        DB 0
        DB 68
        DB 0

        RSEG XDATA_I:XDATA:NOROOT(0)
??serialNumber:
        DATA8
        DS 42
        REQUIRE `?<Initializer for serialNumber>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
hexDigit:
        DB 48
        DB 49
        DB 50
        DB 51
        DB 52
        DB 53
        DB 54
        DB 55
        DB 56
        DB 57
        DB 65
        DB 66
        DB 67
        DB 68
        DB 69
        DB 70

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USBFW_DATA usbfwData
usbfwData:
        DS 20
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USB_SETUP_DATA usbSetupData
usbSetupData:
        DS 5
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
// USB_SETUP_HEADER usbSetupHeader
usbSetupHeader:
        DS 8
        REQUIRE __INIT_XDATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA16
??ProcessFunc:
        DS 2
        REQUIRE __INIT_DATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA8
// USBIRQ_DATA __data usbirqData
usbirqData:
        DS 5
        REQUIRE __INIT_DATA_Z

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     0x8b,#0x0
        CLR     0xe8.0
          CFI EndBlock cfiBlock26
        REQUIRE ??Subroutine27_0
        ; // Fall through to label ??Subroutine27_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine27_0:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock27
//  123 
//  124 /**************************************************************************************************
//  125  * @fn          main
//  126  *
//  127  * @brief       ISR for the reset vector, invoked by IAR after all segment initialization.
//  128  *
//  129  * input parameters
//  130  *
//  131  * None.
//  132  *
//  133  * output parameters
//  134  *
//  135  * None.
//  136  *
//  137  * @return      None.
//  138  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  139 void main(void)
main:
          CFI Block cfiBlock28 Using cfiCommon3
          CFI Function main
        CODE
//  140 {
        FUNCALL main, ublInit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ublExec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        ; Auto size: 0
//  141   /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
//  142    * descriptors in addition to just Channel 0.
//  143    */
//  144   HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
        MOV     A,#(dmaCh0 >> 8) & 0xff
        MOV     0xd5,A
        MOV     0xd4,#dmaCh0 & 0xff
//  145 
//  146   ublInit();
        ; Setup parameters for call to function ublInit
        LCALL   ??ublInit?relay      ; Banked call to: ublInit
//  147   ublExec();
        ; Setup parameters for call to function ublExec
        LCALL   ??ublExec?relay      ; Banked call to: ublExec
//  148 
//  149   HAL_SYSTEM_RESET();
        CLR     0xa8.7
        MOV     0xc9,#-0x55
        MOV     0xc9,#0x5b
??main_0:
        SJMP    ??main_0
          CFI EndBlock cfiBlock28
        REQUIRE DMA0CFGH
        REQUIRE DMA0CFGL
        REQUIRE _A_IEN0
        REQUIRE WDCTL
//  150 }
//  151 
//  152 /**************************************************************************************************
//  153  * @fn          vddWait
//  154  *
//  155  * @brief       Loop waiting for 16 reads of the Vdd over the safe minimum to run.
//  156  *
//  157  * input parameters
//  158  *
//  159  * None.
//  160  *
//  161  * output parameters
//  162  *
//  163  * None.
//  164  *
//  165  * @return      None.
//  166  */
//  167 static void vddWait(void)
//  168 {
//  169   uint8 cnt = 16;
//  170 
//  171   do {
//  172     do {
//  173       ADCCON3 = 0x0F;
//  174       while (!(ADCCON1 & 0x80));
//  175     } while (ADCH < VDD_MIN_RUN);
//  176   } while (--cnt);
//  177 }
//  178 
//  179 /**************************************************************************************************
//  180 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_descriptor_parser.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_descriptor_parser.c
//    4 
//    5     Description:  Parser for USB descriptor structures.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_descriptor_parser
//   10 /// @{
//   11 #define USBDESCRIPTORPARSER_C ///< Modifies the behavior of "EXTERN" in usb_descriptor_parser.h
//   12 #include "usb_firmware_library_headers.h"
//   13 #include "hal_flash.h"
//   14 
//   15 //-------------------------------------------------------------------------------------------------------
//   16 // USBDP internal module data
//   17 static USBDP_DATA __xdata usbdpData; ///< USBDP internal module data
//   18 
//   19 //-------------------------------------------------------------------------------------------------------
//   20 // String descriptors (2-byte unicode data).
//   21 
//   22 // Language ID.
//   23 static const uint8 languageId[4] = {
//   24   4,
//   25   DESC_TYPE_STRING,
//   26   0x09, 0x04  /* US-EN */
//   27 };
//   28 
//   29 // Manufacturer.
//   30 static const uint8 manufacturer[36] = {
//   31   36,
//   32   DESC_TYPE_STRING,
//   33   'T', 0,
//   34   'e', 0,
//   35   'x', 0,
//   36   'a', 0,
//   37   's', 0,
//   38   ' ', 0,
//   39   'I', 0,
//   40   'n', 0,
//   41   's', 0,
//   42   't', 0,
//   43   'r', 0,
//   44   'u', 0,
//   45   'm', 0,
//   46   'e', 0,
//   47   'n', 0,
//   48   't', 0,
//   49   's', 0
//   50 };
//   51 
//   52 // Product.
//   53 #if defined HAL_SB_BOOT_CODE
//   54 static const uint8 product[36] = {
//   55   36,
//   56   DESC_TYPE_STRING,
//   57   'T', 0,
//   58   'I', 0,
//   59   ' ', 0,
//   60   'C', 0,
//   61   'C', 0,
//   62   '2', 0,
//   63   '5', 0,
//   64   '3', 0,
//   65   '1', 0,
//   66   ' ', 0,
//   67   'U', 0,
//   68   'S', 0,
//   69   'B', 0,
//   70   ' ', 0,
//   71   'M', 0,
//   72   'S', 0,
//   73   'D', 0
//   74 };
//   75 #else
//   76 static const uint8 product[36] = {
//   77   36,
//   78   DESC_TYPE_STRING,
//   79   'T', 0,
//   80   'I', 0,
//   81   ' ', 0,
//   82   'C', 0,
//   83   'C', 0,
//   84   '2', 0,
//   85   '5', 0,
//   86   '3', 0,
//   87   '1', 0,
//   88   ' ', 0,
//   89   'U', 0,
//   90   'S', 0,
//   91   'B', 0,
//   92   ' ', 0,
//   93   'C', 0,
//   94   'D', 0,
//   95   'C', 0
//   96 };
//   97 #endif
//   98 
//   99 // Serial Number.
//  100 static uint8 serialNumber[42] = {
//  101   0,  // Initializing to zero vice 42 is the indication to usbdpGetStringDesc() to fill w/ IEEE.
//  102   DESC_TYPE_STRING,
//  103   // Setup for using the 16 nibbles of the hex representation of the IEEE address.
//  104   '_', 0,
//  105   '_', 0,
//  106   '0', 0,
//  107   'X', 0,
//  108 };
//  109 
//  110 const uint8 hexDigit[16] = {
//  111   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
//  112 
//  113 /** \brief	Initializes a search
//  114 *
//  115 * This function must be called before each new search to reset \ref USBDP_DATA.pDesc.
//  116 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  117 void usbdpInit(void)
usbdpInit:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function usbdpInit
        CODE
//  118 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  119    usbdpData.pDesc = (const uint8 __code *) usbDescriptorMarker.pUsbDescStart;
        MOV     DPTR,#usbDescriptorMarker
        LCALL   ??Subroutine28_0 & 0xFFFF
??CrossCallReturnLabel_37:
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        LJMP    ??Subroutine29_0 & 0xFFFF
          CFI EndBlock cfiBlock29
//  120 } // usbdpInit
//  121 
//  122 
//  123 
//  124 
//  125 /** \brief	Locates the descriptor of the wanted type
//  126 *
//  127 * This function parses through the USB descriptors until:
//  128 * \li It hits one with <tt>bDescriptorType = wantedType</tt>, in which case it returns a pointer to
//  129 *     that descriptor, and exits. \ref USBDP_DATA.pDesc will then point to the next descriptor.
//  130 * \li It hits one with <tt>bDescriptorType = haltAtType</tt>, in which case it returns a NULL-pointer,
//  131 *     and exits. \ref USBDP_DATA.pDesc will then point to that descriptor.
//  132 * \li \ref USBDP_DATA.pDesc = \ref usbDescEnd, in which case it returns a NULL-pointer, and exits.
//  133 *     \ref USBDP_DATA.pDesc will continue to point to \ref usbDescEnd.
//  134 *
//  135 * \note To begin a search with this function, \ref usbdpInit should be called first. It should not be
//  136 *       called when continuing a search - for instance after a call to \ref usbdpGetConfigurationDesc().
//  137 *
//  138 * \param[in]       wantedType
//  139 *     The wanted descriptor type (e.g. \ref DESC_TYPE_CONFIG)
//  140 * \param[in]       haltAtType
//  141 *     The parser halts when it reaches this descriptor type, unless \c haltAtType is \c 0 (which in any
//  142 *     case is an invalid \c bDescriptorType value).
//  143 *
//  144 * \return
//  145 *     A pointer to the wanted descriptor type, or \c NULL if it was not found.
//  146 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  147 void __code* usbdpFindNext(uint8 wantedType, uint8 haltAtType)
usbdpFindNext:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function usbdpFindNext
        CODE
//  148 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     A,R1
        MOV     R4,A
        MOV     A,R2
        MOV     R5,A
//  149    void __code *pResult;
//  150    pResult = NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??CrossCallReturnLabel_2
//  151 
//  152    // As long as we haven't reached the end...
//  153    while (usbdpData.pDesc != (void __code *) usbDescriptorMarker.pUsbDescEnd) {
//  154 
//  155       // If we have a match on wantedType...
//  156       if (usbdpData.pDesc[DESC_TYPE_IDX] == wantedType) {
//  157          pResult = (void __code*) usbdpData.pDesc;
//  158          usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
//  159          break;
//  160 
//  161       // If we have a match on haltAtType...
//  162       } else if (usbdpData.pDesc[DESC_TYPE_IDX] == haltAtType) {
//  163          if (haltAtType) break;
//  164       }
//  165 
//  166       // Move on to the next descriptor
//  167       usbdpData.pDesc += usbdpData.pDesc[DESC_LENGTH_IDX];
??usbdpFindNext_0:
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_2:
        MOV     DPTR,#??usbdpData
        LCALL   ??Subroutine28_0 & 0xFFFF
??CrossCallReturnLabel_38:
        MOV     DPTR,#usbDescriptorMarker + 2
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??usbdpFindNext_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??usbdpFindNext_1:
        JZ      ??usbdpFindNext_2
        MOV     DPTR,#??usbdpData + 1
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,R4
        XRL     A,R0
        JNZ     ??usbdpFindNext_3
        MOV     DPTR,#??usbdpData
        LCALL   ??Subroutine32_0 & 0xFFFF
??CrossCallReturnLabel_42:
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_3:
        SJMP    ??usbdpFindNext_2
??usbdpFindNext_3:
        MOV     A,R5
        XRL     A,R0
        JNZ     ??usbdpFindNext_0
        MOV     A,R5
        JZ      ??usbdpFindNext_0
//  168    }
//  169 
//  170    return pResult;
??usbdpFindNext_2:
        SJMP    ??Subroutine30_0
          CFI EndBlock cfiBlock30
//  171 } // usbdpFindNext

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine15:
          CFI Block cfiCond31 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_39
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond32 Using cfiCommon0
          CFI (cfiCond32) Function usbsrGetDescriptor
          CFI (cfiCond32) Conditional ??CrossCallReturnLabel_40
          CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond32) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond32) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond32) CFA_SP SP+-2
          CFI (cfiCond32) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker33 Using cfiCommon1
          CFI (cfiPicker33) NoFunction
          CFI (cfiPicker33) Picker
        MOV     DPTR,#usbSetupData + 3
          CFI EndBlock cfiCond31
          CFI EndBlock cfiCond32
          CFI EndBlock cfiPicker33
        REQUIRE ??Subroutine28_0
        ; // Fall through to label ??Subroutine28_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine28_0:
          CFI Block cfiCond34 Using cfiCommon0
          CFI Function ublAesAuth
          CFI Conditional ??CrossCallReturnLabel_36
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond35 Using cfiCommon0
          CFI (cfiCond35) Function usbdpInit
          CFI (cfiCond35) Conditional ??CrossCallReturnLabel_37
          CFI (cfiCond35) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond35) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond35) CFA_SP SP+-7
          CFI Block cfiCond36 Using cfiCommon0
          CFI (cfiCond36) Function usbdpFindNext
          CFI (cfiCond36) Conditional ??CrossCallReturnLabel_38
          CFI (cfiCond36) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond36) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond36) CFA_SP SP+-7
          CFI Block cfiCond37 Using cfiCommon0
          CFI (cfiCond37) Function usbfwSetupHandler
          CFI (cfiCond37) Conditional ??CrossCallReturnLabel_39
          CFI (cfiCond37) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond37) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond37) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond37) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond37) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond37) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond37) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond37) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond37) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond37) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond37) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond37) CFA_SP SP+-2
          CFI (cfiCond37) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond38 Using cfiCommon0
          CFI (cfiCond38) Function usbsrGetDescriptor
          CFI (cfiCond38) Conditional ??CrossCallReturnLabel_40
          CFI (cfiCond38) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond38) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond38) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond38) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond38) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond38) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond38) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond38) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond38) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond38) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond38) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond38) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond38) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond38) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond38) CFA_SP SP+-2
          CFI (cfiCond38) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker39 Using cfiCommon1
          CFI (cfiPicker39) NoFunction
          CFI (cfiPicker39) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_65:
        RET
          CFI EndBlock cfiCond34
          CFI EndBlock cfiCond35
          CFI EndBlock cfiCond36
          CFI EndBlock cfiCond37
          CFI EndBlock cfiCond38
          CFI EndBlock cfiPicker39

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine23:
          CFI Block cfiCond40 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_62, ??CrossCallReturnLabel_4
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-4
          CFI CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond41 Using cfiCommon0
          CFI (cfiCond41) Function ublExec
          CFI (cfiCond41) Conditional ??CrossCallReturnLabel_62, ??CrossCallReturnLabel_5
          CFI (cfiCond41) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond41) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond41) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond41) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond41) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond41) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond41) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond41) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond41) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond41) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond41) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond41) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond41) CFA_SP SP+-4
          CFI (cfiCond41) CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond42 Using cfiCommon0
          CFI (cfiCond42) Function ublInit
          CFI (cfiCond42) Conditional ??CrossCallReturnLabel_62, ??CrossCallReturnLabel_6
          CFI (cfiCond42) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond42) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond42) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond42) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond42) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond42) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond42) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond42) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond42) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond42) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond42) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond42) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond42) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond42) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond42) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond42) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond42) CFA_SP SP+-4
          CFI (cfiCond42) CFA_XSP16 add(XSP16, 20)
          CFI Block cfiCond43 Using cfiCommon0
          CFI (cfiCond43) Function usbfwSetupHandler
          CFI (cfiCond43) Conditional ??CrossCallReturnLabel_65, ??CrossCallReturnLabel_39
          CFI (cfiCond43) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond43) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond43) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond43) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond43) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond43) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond43) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond43) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond43) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond43) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond43) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond43) CFA_SP SP+-4
          CFI (cfiCond43) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond44 Using cfiCommon0
          CFI (cfiCond44) Function usbsrGetDescriptor
          CFI (cfiCond44) Conditional ??CrossCallReturnLabel_65, ??CrossCallReturnLabel_40
          CFI (cfiCond44) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond44) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond44) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond44) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond44) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond44) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond44) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond44) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond44) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond44) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond44) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond44) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond44) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond44) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond44) CFA_SP SP+-4
          CFI (cfiCond44) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond45 Using cfiCommon0
          CFI (cfiCond45) Function ublAesAuth
          CFI (cfiCond45) Conditional ??CrossCallReturnLabel_65, ??CrossCallReturnLabel_36
          CFI (cfiCond45) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond45) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond45) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond45) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond45) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond45) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond45) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond45) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond45) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond45) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond45) CFA_SP SP+-4
          CFI (cfiCond45) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond46 Using cfiCommon0
          CFI (cfiCond46) Function usbdpInit
          CFI (cfiCond46) Conditional ??CrossCallReturnLabel_65, ??CrossCallReturnLabel_37
          CFI (cfiCond46) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond46) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond46) CFA_SP SP+-9
          CFI Block cfiCond47 Using cfiCommon0
          CFI (cfiCond47) Function usbdpFindNext
          CFI (cfiCond47) Conditional ??CrossCallReturnLabel_65, ??CrossCallReturnLabel_38
          CFI (cfiCond47) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond47) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond47) CFA_SP SP+-9
          CFI Block cfiCond48 Using cfiCommon0
          CFI (cfiCond48) Function usbdpGetDeviceDesc
          CFI (cfiCond48) Conditional ??CrossCallReturnLabel_63, ??CrossCallReturnLabel_7
          CFI (cfiCond48) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond48) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond48) CFA_SP SP+-9
          CFI Block cfiCond49 Using cfiCommon0
          CFI (cfiCond49) Function usbdpGetConfigurationDesc
          CFI (cfiCond49) Conditional ??CrossCallReturnLabel_63, ??CrossCallReturnLabel_8
          CFI (cfiCond49) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond49) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond49) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond49) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond49) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond49) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond49) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond49) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond49) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond49) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond49) CFA_SP SP+-4
          CFI (cfiCond49) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond50 Using cfiCommon0
          CFI (cfiCond50) Function usbsrSetAddress
          CFI (cfiCond50) Conditional ??CrossCallReturnLabel_64, ??CrossCallReturnLabel_13
          CFI (cfiCond50) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond50) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond50) CFA_SP SP+-9
          CFI Block cfiCond51 Using cfiCommon0
          CFI (cfiCond51) Function usbsrGetDescriptor
          CFI (cfiCond51) Conditional ??CrossCallReturnLabel_64, ??CrossCallReturnLabel_14
          CFI (cfiCond51) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond51) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond51) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond51) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond51) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond51) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond51) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond51) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond51) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond51) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond51) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond51) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond51) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond51) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond51) CFA_SP SP+-4
          CFI (cfiCond51) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond52 Using cfiCommon0
          CFI (cfiCond52) Function ??ConfigureEndpoints
          CFI (cfiCond52) Conditional ??CrossCallReturnLabel_64, ??CrossCallReturnLabel_15
          CFI (cfiCond52) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond52) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond52) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond52) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond52) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond52) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond52) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond52) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond52) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond52) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond52) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond52) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond52) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond52) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond52) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond52) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond52) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond52) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond52) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond52) CFA_SP SP+-4
          CFI (cfiCond52) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiCond53 Using cfiCommon0
          CFI (cfiCond53) Function usbsrGetStatus
          CFI (cfiCond53) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_59
          CFI (cfiCond53) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond53) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond53) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond53) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond53) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond53) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond53) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond53) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond53) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond53) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond53) CFA_SP SP+-4
          CFI (cfiCond53) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond54 Using cfiCommon0
          CFI (cfiCond54) Function usbsrGetConfiguration
          CFI (cfiCond54) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_60
          CFI (cfiCond54) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond54) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond54) CFA_SP SP+-9
          CFI Block cfiCond55 Using cfiCommon0
          CFI (cfiCond55) Function usbsrGetInterface
          CFI (cfiCond55) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_61
          CFI (cfiCond55) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond55) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond55) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond55) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond55) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond55) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond55) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond55) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond55) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond55) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond55) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond55) CFA_SP SP+-4
          CFI (cfiCond55) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond56 Using cfiCommon0
          CFI (cfiCond56) Function ublExec
          CFI (cfiCond56) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_49
          CFI (cfiCond56) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond56) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond56) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond56) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond56) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond56) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond56) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond56) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond56) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond56) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond56) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond56) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond56) CFA_SP SP+-4
          CFI (cfiCond56) CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond57 Using cfiCommon0
          CFI (cfiCond57) Function usbfwSetupHandler
          CFI (cfiCond57) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_50
          CFI (cfiCond57) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond57) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond57) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond57) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond57) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond57) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond57) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond57) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond57) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond57) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond57) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond57) CFA_SP SP+-4
          CFI (cfiCond57) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond58 Using cfiCommon0
          CFI (cfiCond58) Function ??ChangeFeature
          CFI (cfiCond58) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_51
          CFI (cfiCond58) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond58) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond58) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond58) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond58) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond58) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond58) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond58) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond58) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond58) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond58) CFA_SP SP+-4
          CFI (cfiCond58) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond59 Using cfiCommon0
          CFI (cfiCond59) Function ??ChangeFeature
          CFI (cfiCond59) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_52
          CFI (cfiCond59) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond59) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond59) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond59) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond59) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond59) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond59) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond59) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond59) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond59) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond59) CFA_SP SP+-4
          CFI (cfiCond59) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond60 Using cfiCommon0
          CFI (cfiCond60) Function usbsrSetAddress
          CFI (cfiCond60) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_53
          CFI (cfiCond60) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond60) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond60) CFA_SP SP+-9
          CFI Block cfiCond61 Using cfiCommon0
          CFI (cfiCond61) Function usbsrSetAddress
          CFI (cfiCond61) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_54
          CFI (cfiCond61) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond61) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond61) CFA_SP SP+-9
          CFI Block cfiCond62 Using cfiCommon0
          CFI (cfiCond62) Function usbsrGetConfiguration
          CFI (cfiCond62) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_55
          CFI (cfiCond62) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond62) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond62) CFA_SP SP+-9
          CFI Block cfiCond63 Using cfiCommon0
          CFI (cfiCond63) Function usbsrSetConfiguration
          CFI (cfiCond63) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_56
          CFI (cfiCond63) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond63) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond63) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond63) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond63) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond63) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond63) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond63) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond63) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond63) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond63) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond63) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond63) CFA_SP SP+-4
          CFI (cfiCond63) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond64 Using cfiCommon0
          CFI (cfiCond64) Function usbsrSetConfiguration
          CFI (cfiCond64) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_57
          CFI (cfiCond64) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond64) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond64) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond64) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond64) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond64) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond64) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond64) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond64) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond64) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond64) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond64) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond64) CFA_SP SP+-4
          CFI (cfiCond64) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond65 Using cfiCommon0
          CFI (cfiCond65) Function usbsrSetInterface
          CFI (cfiCond65) Conditional ??CrossCallReturnLabel_66, ??CrossCallReturnLabel_58
          CFI (cfiCond65) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond65) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond65) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond65) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond65) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond65) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond65) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond65) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond65) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond65) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond65) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond65) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond65) CFA_SP SP+-4
          CFI (cfiCond65) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiPicker66 Using cfiCommon1
          CFI (cfiPicker66) NoFunction
          CFI (cfiPicker66) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        RET
          CFI EndBlock cfiCond40
          CFI EndBlock cfiCond41
          CFI EndBlock cfiCond42
          CFI EndBlock cfiCond43
          CFI EndBlock cfiCond44
          CFI EndBlock cfiCond45
          CFI EndBlock cfiCond46
          CFI EndBlock cfiCond47
          CFI EndBlock cfiCond48
          CFI EndBlock cfiCond49
          CFI EndBlock cfiCond50
          CFI EndBlock cfiCond51
          CFI EndBlock cfiCond52
          CFI EndBlock cfiCond53
          CFI EndBlock cfiCond54
          CFI EndBlock cfiCond55
          CFI EndBlock cfiCond56
          CFI EndBlock cfiCond57
          CFI EndBlock cfiCond58
          CFI EndBlock cfiCond59
          CFI EndBlock cfiCond60
          CFI EndBlock cfiCond61
          CFI EndBlock cfiCond62
          CFI EndBlock cfiCond63
          CFI EndBlock cfiCond64
          CFI EndBlock cfiCond65
          CFI EndBlock cfiPicker66

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
          CFI Block cfiCond67 Using cfiCommon0
          CFI Function usbdpFindNext
          CFI Conditional ??CrossCallReturnLabel_2
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond68 Using cfiCommon0
          CFI (cfiCond68) Function usbdpFindNext
          CFI (cfiCond68) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond68) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond68) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond68) CFA_SP SP+-7
          CFI Block cfiPicker69 Using cfiCommon1
          CFI (cfiPicker69) NoFunction
          CFI (cfiPicker69) Picker
        MOV     DPTR,#??usbdpData
        LCALL   ?Subroutine24 & 0xFFFF
??CrossCallReturnLabel_30:
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     DPTR,#??usbdpData
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        RET
          CFI EndBlock cfiCond67
          CFI EndBlock cfiCond68
          CFI EndBlock cfiPicker69

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine24:
          CFI Block cfiCond70 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_31, ??CrossCallReturnLabel_16
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-4
          CFI CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond71 Using cfiCommon0
          CFI (cfiCond71) Function ??gpioInit
          CFI (cfiCond71) Conditional ??CrossCallReturnLabel_31, ??CrossCallReturnLabel_17
          CFI (cfiCond71) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond71) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond71) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond71) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond71) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond71) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond71) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond71) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond71) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond71) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond71) CFA_SP SP+-4
          CFI (cfiCond71) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond72 Using cfiCommon0
          CFI (cfiCond72) Function usbdpFindNext
          CFI (cfiCond72) Conditional ??CrossCallReturnLabel_30, ??CrossCallReturnLabel_2
          CFI (cfiCond72) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond72) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond72) CFA_SP SP+-9
          CFI Block cfiCond73 Using cfiCommon0
          CFI (cfiCond73) Function usbdpFindNext
          CFI (cfiCond73) Conditional ??CrossCallReturnLabel_30, ??CrossCallReturnLabel_3
          CFI (cfiCond73) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond73) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond73) CFA_SP SP+-9
          CFI Block cfiPicker74 Using cfiCommon1
          CFI (cfiPicker74) NoFunction
          CFI (cfiPicker74) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        RET
          CFI EndBlock cfiCond70
          CFI EndBlock cfiCond71
          CFI EndBlock cfiCond72
          CFI EndBlock cfiCond73
          CFI EndBlock cfiPicker74
//  172 
//  173 
//  174 
//  175 
//  176 /** \brief	Locates the (one and only) device descriptor
//  177 *
//  178 * \note It is not necessary to call \ref usbdpInit() before this function.
//  179 *
//  180 * \return
//  181 *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
//  182 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  183 USB_DEVICE_DESCRIPTOR __code* usbdpGetDeviceDesc(void)
usbdpGetDeviceDesc:
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function usbdpGetDeviceDesc
        CODE
//  184 {
        FUNCALL usbdpGetDeviceDesc, usbdpFindNext
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  185    usbdpInit();
        LCALL   ?Subroutine11 & 0xFFFF
//  186    return usbdpFindNext(DESC_TYPE_DEVICE, 0);
??CrossCallReturnLabel_7:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
        SJMP    ??Subroutine30_0
          CFI EndBlock cfiBlock75
//  187 } // usbdpGetDeviceDesc

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
          CFI Block cfiBlock76 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOVX    @DPTR,A
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
          CFI EndBlock cfiBlock76
        REQUIRE ??Subroutine29_0
        ; // Fall through to label ??Subroutine29_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine29_0:
          CFI Block cfiBlock77 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        MOVX    @DPTR,A
          CFI EndBlock cfiBlock77
        REQUIRE ??Subroutine30_0
        ; // Fall through to label ??Subroutine30_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine30_0:
          CFI Block cfiBlock78 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+-5
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
          CFI CFA_SP SP+-4
          CFI DPH0 SameValue
        POP     DPL
          CFI CFA_SP SP+-3
          CFI DPL0 SameValue
        LJMP    ?BRET
          CFI EndBlock cfiBlock78
//  188 
//  189 
//  190 
//  191 
//  192 /** \brief	Locates a configuration descriptor
//  193 *
//  194 * The search will either look for a descriptor with a specific
//  195 * \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue, or simply take the n'th descriptor (by "index")
//  196 *
//  197 * \note It is not necessary to call \ref usbdpInit() before this function.
//  198 *
//  199 * \param[in]       cfgValue
//  200 *     The configuration value to search for (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue), or
//  201 *     0 to find descriptor by index
//  202 * \param[in]       cfgIndex
//  203 *     A zero-based index for the configuration descriptor to find.
//  204 *     This value is ignored unless \c cfgValue is 0.
//  205 *
//  206 * \return
//  207 *     A pointer to the \ref USB_DEVICE_DESCRIPTOR, or \c NULL if it was not found.
//  208 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  209 USB_CONFIGURATION_DESCRIPTOR __code* usbdpGetConfigurationDesc(uint8 cfgValue, uint8 cfgIndex)
usbdpGetConfigurationDesc:
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function usbdpGetConfigurationDesc
        CODE
//  210 {
        FUNCALL usbdpGetConfigurationDesc, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
        MOV     A,R2
        MOV     R7,A
//  211    USB_CONFIGURATION_DESCRIPTOR __code *pConfigurationDesc;
//  212    usbdpInit();
        LCALL   ?Subroutine11 & 0xFFFF
//  213 
//  214    // As long as there are more configuration descriptors...
//  215    while (pConfigurationDesc = usbdpFindNext(DESC_TYPE_CONFIG, 0)) {
??CrossCallReturnLabel_8:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbdpGetConfigurationDesc_0
//  216 
//  217       // Search by value?
//  218       if (cfgValue) {
        MOV     A,R6
        JZ      ??usbdpGetConfigurationDesc_1
//  219          if (cfgValue == pConfigurationDesc->bConfigurationValue) break;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R6
        JNZ     ??CrossCallReturnLabel_8
        SJMP    ??usbdpGetConfigurationDesc_0
//  220 
//  221       // Search by index? (search cfgIndex+1 times)
//  222       } else if (!cfgIndex--) {
??usbdpGetConfigurationDesc_1:
        MOV     A,R7
        MOV     R0,A
        MOV     A,#-0x1
        ADD     A,R0
        DEC     R7
        INC     A
        JNZ     ??CrossCallReturnLabel_8
//  223          break;
//  224       }
//  225    }
//  226 
//  227    return pConfigurationDesc;
??usbdpGetConfigurationDesc_0:
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock79
//  228 } // usbdpGetConfigurationDesc

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine11:
          CFI Block cfiCond80 Using cfiCommon0
          CFI Function usbdpGetDeviceDesc
          CFI Conditional ??CrossCallReturnLabel_7
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond81 Using cfiCommon0
          CFI (cfiCond81) Function usbdpGetConfigurationDesc
          CFI (cfiCond81) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond81) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond81) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond81) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond81) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond81) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond81) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond81) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond81) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond81) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond81) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond81) CFA_SP SP+-2
          CFI (cfiCond81) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiPicker82 Using cfiCommon1
          CFI (cfiPicker82) NoFunction
          CFI (cfiPicker82) Picker
        MOV     DPTR,#usbDescriptorMarker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_63:
        MOV     DPTR,#??usbdpData
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        RET
          CFI EndBlock cfiCond80
          CFI EndBlock cfiCond81
          CFI EndBlock cfiPicker82
//  229 
//  230 
//  231 
//  232 
//  233 /** \brief	Locates an interface descriptor
//  234 *
//  235 * The function will first go to the configuration descriptor that matches the supplied configuration
//  236 * value, and then locate the interface descriptor that matches the given interface number and alternate
//  237 * setting.
//  238 *
//  239 * \note It is not necessary to call \ref usbdpInit() before this function.
//  240 *
//  241 * \param[in]       cfgValue
//  242 *     The configuration value (\ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue)
//  243 * \param[in]       intNumber
//  244 *     The interface number (\ref USB_INTERFACE_DESCRIPTOR.bInterfaceNumber)
//  245 * \param[in]       altSetting
//  246 *     The alternate setting (\ref USB_INTERFACE_DESCRIPTOR.bAlternateSetting)
//  247 *
//  248 * \return
//  249 *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
//  250 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  251 USB_INTERFACE_DESCRIPTOR __code* usbdpGetInterfaceDesc(uint8 cfgValue, uint8 intNumber, uint8 altSetting)
usbdpGetInterfaceDesc:
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function usbdpGetInterfaceDesc
        CODE
//  252 {
        FUNCALL usbdpGetInterfaceDesc, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbdpGetInterfaceDesc, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R7,A
        MOV     ?V0,R3
//  253    USB_INTERFACE_DESCRIPTOR __code *pInterfaceDesc;
//  254 
//  255    // First get to the correct configuration
//  256    usbdpGetConfigurationDesc(cfgValue, 0);
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
//  257 
//  258    // Then find a match on the interface
//  259    while (pInterfaceDesc = usbdpFindNext(DESC_TYPE_INTERFACE, DESC_TYPE_CONFIG)) {
??usbdpGetInterfaceDesc_0:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x2
        MOV     R1,#0x4
        LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbdpGetInterfaceDesc_1
//  260       if ((pInterfaceDesc->bInterfaceNumber == intNumber) && (pInterfaceDesc->bAlternateSetting == altSetting)) {
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R7
        JNZ     ??usbdpGetInterfaceDesc_0
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,?V0
        JNZ     ??usbdpGetInterfaceDesc_0
          CFI EndBlock cfiBlock83
//  261          break;
//  262       }
//  263    }
//  264 
//  265    return pInterfaceDesc;
??usbdpGetInterfaceDesc_1:
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0
//  266 } // usbdpGetInterfaceDesc

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
          CFI Block cfiBlock84 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock84
//  267 
//  268 
//  269 
//  270 
//  271 /** \brief	Locates a string descriptor
//  272 *
//  273 * \note It is not necessary to call \ref usbdpInit() before this function.
//  274 *
//  275 * \param[in]       strIndex
//  276 *     A zero-based index that matches the "iXxxxxxxxxx" string indexes in the other descriptors
//  277 *
//  278 * \return
//  279 *     A pointer to the \ref USB_INTERFACE_DESCRIPTOR, or \c NULL if it was not found.
//  280 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  281 USB_STRING_DESCRIPTOR* usbdpGetStringDesc(uint8 strIndex)
usbdpGetStringDesc:
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function usbdpGetStringDesc
        CODE
//  282 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R1
//  283   USB_STRING_DESCRIPTOR *pStringDesc = NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
//  284 
//  285 #ifdef MS_EXT_C_ID
//  286   /* TODO: Find the Microsoft OS String Descriptor?
//  287   usbdpInit();
//  288 
//  289   if (strIndex == 0xEE){
//  290     // Find the Microsoft OS String Descriptor
//  291     do{
//  292       pStringDesc = usbdpFindNext(DESC_TYPE_STRING, 0);
//  293     }while (pStringDesc != NULL && pStringDesc->bLength != 18);
//  294   } else
//  295   */
//  296 #endif
//  297   {
//  298     switch (strIndex)
        JZ      ??usbdpGetStringDesc_0
        DEC     A
        JZ      ??usbdpGetStringDesc_1
        DEC     A
        JZ      ??usbdpGetStringDesc_2
        DEC     A
        JZ      ??usbdpGetStringDesc_3
        SJMP    ??usbdpGetStringDesc_4
//  299     {
//  300     case 0:
//  301       pStringDesc = (USB_STRING_DESCRIPTOR *)languageId;
??usbdpGetStringDesc_0:
        MOV     R2,#??languageId & 0xff
        MOV     R3,#(??languageId >> 8) & 0xff
//  302       break;
        SJMP    ??usbdpGetStringDesc_4
//  303 
//  304     case 1:
//  305       pStringDesc = (USB_STRING_DESCRIPTOR *)manufacturer;
??usbdpGetStringDesc_1:
        MOV     R2,#??manufacturer & 0xff
        MOV     R3,#(??manufacturer >> 8) & 0xff
//  306       break;
        SJMP    ??usbdpGetStringDesc_4
//  307 
//  308     case 2:
//  309       pStringDesc = (USB_STRING_DESCRIPTOR *)product;
??usbdpGetStringDesc_2:
        MOV     R2,#??product & 0xff
        MOV     R3,#(??product >> 8) & 0xff
//  310       break;
        SJMP    ??usbdpGetStringDesc_4
//  311 
//  312     case 3:
//  313       if (serialNumber[0] == 0)
??usbdpGetStringDesc_3:
        MOV     DPTR,#??serialNumber
        MOVX    A,@DPTR
        JNZ     ??usbdpGetStringDesc_5
//  314       {
//  315 #if (defined HAL_SB_BOOT_CODE || defined CC253X_MACNP || defined CC2531DK)
//  316         #include <string.h>
//  317         uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
        MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
        MOV     R4,?XSP + 0
        MOV     R5,?XSP + 1
        MOV     A,#0x8
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  318         /*
//  319         uint8 nullAddr[HAL_FLASH_IEEE_SIZE] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//  320         uint8 aExtendedAddress[HAL_FLASH_IEEE_SIZE];
//  321 
//  322         // Attempt to read the extended address from the location on the lock bits page
//  323         // where the programming tools know to reserve it.
//  324         HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET,
//  325                         aExtendedAddress, HAL_FLASH_IEEE_SIZE);
//  326 
//  327         if (!memcmp(aExtendedAddress, nullAddr, HAL_FLASH_IEEE_SIZE))
//  328         {
//  329           // Attempt to read the extended address from the designated location in the Info Page.
//  330           memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), HAL_FLASH_IEEE_SIZE);
//  331         }
//  332          */
//  333 #endif
//  334         // Load the 16 nibbles of the hex representation of the IEEE address into the serialNumber
//  335         // string in big-endian (i.e. human-readable) order.
//  336         for (uint8 idx = sizeof(serialNumber)-2, cnt=0; cnt < HAL_FLASH_IEEE_SIZE; cnt++, idx -= 4)
        MOV     R4,#0x28
        MOV     R5,A
//  337         {
//  338           serialNumber[idx]   = hexDigit[aExtendedAddress[cnt] & 0x0F];
??usbdpGetStringDesc_6:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,DPL
        ADD     A,R5
        MOV     DPL,A
        CLR     A
        ADDC    A,DPH
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,#??serialNumber & 0xff
        ADD     A,R4
        MOV     R0,A
        CLR     A
        ADDC    A,#(??serialNumber >> 8) & 0xff
        MOV     R1,A
        MOV     A,R7
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_0:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    @DPTR,A
//  339           serialNumber[idx-2] = hexDigit[aExtendedAddress[cnt] / 16];
        MOV     A,R7
        SWAP    A
        LCALL   ?Subroutine6 & 0xFFFF
//  340         }
??CrossCallReturnLabel_1:
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R0
        ADD     A,#-0x2
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     R5
        MOV     A,#-0x4
        ADD     A,R4
        MOV     R4,A
        MOV     A,R5
        CLR     C
        SUBB    A,#0x8
        JC      ??usbdpGetStringDesc_6
//  341         serialNumber[0] = sizeof(serialNumber);
        MOV     DPTR,#??serialNumber
        MOV     A,#0x2a
        MOVX    @DPTR,A
//  342       }
//  343       pStringDesc = (USB_STRING_DESCRIPTOR *)serialNumber;
??usbdpGetStringDesc_5:
        MOV     R2,#??serialNumber & 0xff
        MOV     R3,#(??serialNumber >> 8) & 0xff
//  344       break;
//  345 
//  346     default:
//  347       break;
//  348     }
//  349   }
//  350 
//  351   return pStringDesc;
??usbdpGetStringDesc_4:
        MOV     A,#0x8
        LJMP    ?Subroutine5 & 0xFFFF
          CFI EndBlock cfiBlock85
//  352 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
          CFI Block cfiCond86 Using cfiCommon0
          CFI Function usbdpGetStringDesc
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 18)
          CFI Block cfiCond87 Using cfiCommon0
          CFI (cfiCond87) Function usbdpGetStringDesc
          CFI (cfiCond87) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond87) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond87) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond87) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond87) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond87) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond87) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond87) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond87) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond87) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond87) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond87) CFA_SP SP+-2
          CFI (cfiCond87) CFA_XSP16 add(XSP16, 18)
          CFI Block cfiPicker88 Using cfiCommon1
          CFI (cfiPicker88) NoFunction
          CFI (cfiPicker88) Picker
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,#hexDigit & 0xff
        ADD     A,R2
        MOV     DPL,A
        CLR     A
        ADDC    A,#(hexDigit >> 8) & 0xff
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
          CFI EndBlock cfiCond86
          CFI EndBlock cfiCond87
          CFI EndBlock cfiPicker88
//  353 /// @}
//  354 
//  355 /*
//  356 +------------------------------------------------------------------------------
//  357 |  Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
//  358 |
//  359 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  360 |  granted under the terms of a software license agreement between the user who
//  361 |  downloaded the software, his/her employer (which must be your employer) and
//  362 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  363 |  unless you agree to abide by the terms of the License. The License limits
//  364 |  your use, and you acknowledge, that the Software may not be modified, copied
//  365 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  366 |  solely and exclusively in conjunction with a Texas Instruments radio
//  367 |  frequency transceiver, which is integrated into your product. Other than for
//  368 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  369 |  works of, modify, distribute, perform, display or sell this Software and/or
//  370 |  its documentation for any purpose.
//  371 |
//  372 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  373 |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  374 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  375 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  376 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  377 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  378 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  379 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  380 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  381 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  382 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  383 |
//  384 |  Should you have any questions regarding your right to use this Software,
//  385 |  contact Texas Instruments Incorporated at www.TI.com.
//  386 |
//  387 +------------------------------------------------------------------------------
//  388 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_framework.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_framework.c
//    4 
//    5     Description:  USB library common functionality.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_framework
//   10 /// @{
//   11 #define USBFRAMEWORK_C ///< Modifies the behavior of "EXTERN" in usb_framework.h
//   12 #include "usb_firmware_library_headers.h"
//   13 #include "usb_board_cfg.h"
//   14 
//   15 // Function pointer used by usbfwSetupHandler()
//   16 static VFPTR __data ProcessFunc;
//   17 
//   18 /** \brief Initializes the USB framework
//   19  *
//   20  * This function should be called when the microcontroller is ready to accept USB traffic. It enables the
//   21  * USB peripheral unit and enables the pull-up resistor on the D+ line. Endpoint status, current
//   22  * configuration value, etc. are initialized and evenetually re-initialized in the
//   23  * \ref usbfwResetHandler() function.
//   24  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   25 void usbfwInit(void)
usbfwInit:
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function usbfwInit
        CODE
//   26 {
        FUNCALL usbfwInit, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   27     // Set default values
//   28     usbfwData.selfPowered = (usbdpGetConfigurationDesc(1, 0)->bmAttributes & 0x40) ? TRUE : FALSE;
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     C,0xE0 /* A   */.6
        MOV     DPTR,#usbfwData + 19
        JNC     ??usbfwInit_0
        MOV     A,#0x1
        SJMP    ??usbfwInit_1
??usbfwInit_0:
        CLR     A
??usbfwInit_1:
        MOVX    @DPTR,A
//   29     usbfwData.remoteWakeup = FALSE;
        MOV     DPTR,#usbfwData + 18
        CLR     A
        MOVX    @DPTR,A
//   30 
//   31     HAL_USB_ENABLE();
        MOV     DPTR,#0x620f
        MOV     A,#0x3
        MOVX    @DPTR,A
??usbfwInit_2:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JNC     ??usbfwInit_2
//   32 
//   33     // Enable Resume Interrupt
//   34     HAL_USB_RESUME_INT_ENABLE();
//   35 
//   36 } // usbfwInit
        LJMP    ??Subroutine30_0 & 0xFFFF
          CFI EndBlock cfiBlock89
//   37 
//   38 
//   39 
//   40 
//   41 /** \brief Handles USB reset signalling
//   42  *
//   43  * This function should be called, either from the USB interrupt or the main loop, when the \c USBCIF.RST
//   44  * flag has been set. Keep in mind that all bits in \c USBCIF register are cleared when the register is
//   45  * read. The function puts the device into the default state (not yet addressed), and puts all endpoints
//   46  * (except EP0) into the \ref EP_HALT state
//   47  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   48 void usbfwResetHandler(void)
usbfwResetHandler:
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function usbfwResetHandler
        CODE
//   49 {
        FUNCALL usbfwResetHandler, usbfwSetAllEpStatus
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   50 
//   51    // Reset the USB state
//   52    usbfwData.usbState = DEV_DEFAULT;
        MOV     DPTR,#usbfwData
        MOV     A,#0x2
        MOVX    @DPTR,A
//   53    usbfwData.configurationValue = 0;
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//   54 
//   55    // Reset all endpoints
//   56    usbfwData.ep0Status = EP_IDLE;
        MOV     DPTR,#usbfwData + 7
        MOVX    @DPTR,A
//   57    usbfwSetAllEpStatus(EP_HALT);
        ; Setup parameters for call to function usbfwSetAllEpStatus
        MOV     R1,#0x3
        LCALL   ??usbfwSetAllEpStatus?relay; Banked call to: usbfwSetAllEpStatus
//   58 
//   59    // Reset last function pointer
//   60    ProcessFunc = NULL;
        MOV     ??ProcessFunc+0x0,#0x0
        MOV     ??ProcessFunc+0x1,#0x0
//   61 
//   62 } // usbfwResetHandler
        LJMP    ??Subroutine30_0 & 0xFFFF
          CFI EndBlock cfiBlock90
//   63 
//   64 
//   65 
//   66 
//   67 /** \brief USB Setup Handler
//   68  *
//   69  * This function should be called either from the USB interrupt or the main loop when the \c USBIIF.EP0IF
//   70  * flag has been set. Keep in mind that all bits in \c USBIIF register are cleared when the register is
//   71  * read. A detailed description of the framework is found in the \ref section_setup_handler_usage
//   72  * section.
//   73  *
//   74  * \note The USB header data is always little-endian, so if a big-endian compiler is used (such as Keil
//   75  * C51), the 16-bit values in the \ref usbSetupHeader must be flipped before they are used.
//   76  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   77 void usbfwSetupHandler(void)
usbfwSetupHandler:
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function usbfwSetupHandler
        CODE
//   78 {
        FUNCALL usbfwSetupHandler, usbfwReadFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbfwReadFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetAddress
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetFeature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrClearFeature
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetConfiguration
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrSetInterface
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetStatus
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetDescriptor
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetConfiguration
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbsrGetInterface
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbvrHookProcessOut
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbvrHookProcessIn
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbcrHookProcessOut
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbcrHookProcessIn
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbfwSetupHandler, usbfwWriteFifo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//   79    uint8 controlReg;
//   80    uint8 bytesNow;
//   81    uint8 oldEndpoint;
//   82 
//   83    // Save the old index setting, then select endpoint 0 and fetch the control register
//   84    oldEndpoint = USBFW_GET_SELECTED_ENDPOINT();
        MOV     DPTR,#0x620e
        MOVX    A,@DPTR
        MOV     R6,A
//   85    USBFW_SELECT_ENDPOINT(0);
        CLR     A
        MOVX    @DPTR,A
//   86    controlReg = USBCS0;
        MOV     DPTR,#0x6211
        MOVX    A,@DPTR
        MOV     R7,A
//   87 
//   88    // The last transfer was ended prematurely by a new SETUP packet
//   89    if (controlReg & USBCS0_SETUP_END) {
        MOV     C,0xE0 /* A   */.4
        JNC     ??usbfwSetupHandler_0
//   90       USBCS0 = USBCS0_CLR_SETUP_END;
        MOV     A,#-0x80
        MOVX    @DPTR,A
//   91       usbfwData.ep0Status = EP_CANCEL;
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x7
        MOVX    @DPTR,A
//   92       if (ProcessFunc) ProcessFunc();
        MOV     A,??ProcessFunc+0x0
        ORL     A,??ProcessFunc+0x1
        JZ      ??usbfwSetupHandler_1
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//   93       usbfwData.ep0Status = EP_IDLE;
??usbfwSetupHandler_1:
        MOV     DPTR,#usbfwData + 7
        CLR     A
        MOVX    @DPTR,A
//   94    }
//   95 
//   96    // A STALL handshake was transmitted to the PC
//   97    if (controlReg & USBCS0_SENT_STALL) {
??usbfwSetupHandler_0:
        MOV     A,R7
        MOV     C,0xE0 /* A   */.2
        JNC     ??usbfwSetupHandler_2
//   98       USBCS0 = 0x00;
        MOV     DPTR,#0x6211
        CLR     A
        MOVX    @DPTR,A
//   99       usbfwData.ep0Status = EP_IDLE;
        MOV     DPTR,#usbfwData + 7
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_3
//  100    }
//  101 
//  102    // Receive OUT packets
//  103    if (usbfwData.ep0Status == EP_RX) {
??usbfwSetupHandler_2:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x2
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_4
//  104 
//  105       // Read FIFO
//  106       bytesNow = USBCNT0;
        MOV     DPTR,#0x6216
        MOVX    A,@DPTR
        MOV     R7,A
//  107       usbfwReadFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
        ; Setup parameters for call to function usbfwReadFifo
        MOV     DPTR,#usbSetupData
        LCALL   ?PUSH_XSTACK8_X_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R7
        MOV     R1,A
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   ??usbfwReadFifo?relay; Banked call to: usbfwReadFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  108       usbSetupData.bytesLeft -= bytesNow;
        MOV     ?V0,R7
        MOV     DPTR,#usbSetupData + 3
        LCALL   ?Subroutine18 & 0xFFFF
//  109       usbSetupData.pBuffer += bytesNow;
??CrossCallReturnLabel_20:
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_47:
        MOV     A,R1
        ADD     A,R7
        LCALL   ?Subroutine22 & 0xFFFF
//  110 
//  111       // Arm the endpoint
//  112       USBCS0 = usbSetupData.bytesLeft ? USBCS0_CLR_OUTPKT_RDY : (USBCS0_CLR_OUTPKT_RDY | USBCS0_DATA_END);
??CrossCallReturnLabel_28:
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_50:
        JZ      ??usbfwSetupHandler_5
        MOV     A,#0x40
        SJMP    ??usbfwSetupHandler_6
??usbfwSetupHandler_5:
        MOV     A,#0x48
??usbfwSetupHandler_6:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  113 
//  114       // Make a call to the appropriate request handler when done
//  115       if (usbSetupData.bytesLeft == 0) {
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??usbfwSetupHandler_7 & 0xFFFF
        LJMP    ??usbfwSetupHandler_8 & 0xFFFF
//  116          if (ProcessFunc) ProcessFunc();
//  117          usbfwData.ep0Status = EP_IDLE;
//  118       }
//  119 
//  120       // Return here since nothing more will happen until the next interrupt
//  121       USBFW_SELECT_ENDPOINT(oldEndpoint);
//  122       return;
//  123 
//  124    // Let the application handle the reception
//  125    } else if (usbfwData.ep0Status == EP_MANUAL_RX) {
??usbfwSetupHandler_4:
        MOV     A,#0x6
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_9
//  126       ProcessFunc();
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  127    }
//  128 
//  129    // Receive SETUP header
//  130    if (usbfwData.ep0Status == EP_IDLE) {
??usbfwSetupHandler_9:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??usbfwSetupHandler_10 & 0xFFFF
//  131       if (controlReg & USBCS0_OUTPKT_RDY) {
??usbfwSetupHandler_3:
        MOV     A,R7
        MOV     C,0xE0 /* A   */.0
        JC      $+5
        LJMP    ??usbfwSetupHandler_7 & 0xFFFF
//  132          usbfwReadFifo(&USBF0, 8, (uint8 __xdata *) &usbSetupHeader);
        ; Setup parameters for call to function usbfwReadFifo
        MOV     ?V0,#usbSetupHeader & 0xff
        MOV     ?V1,#(usbSetupHeader >> 8) & 0xff
        MOV     ?V2,#0x0
        MOV     R0,#?V0
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R1,#0x8
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   ??usbfwReadFifo?relay; Banked call to: usbfwReadFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  133 
//  134          // Handle control transfers individually
//  135          ProcessFunc = NULL;
        MOV     ??ProcessFunc+0x0,#0x0
        MOV     ??ProcessFunc+0x1,#0x0
//  136          switch (usbSetupHeader.requestType & (RT_MASK_TYPE | RT_MASK_DIR)) {
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ANL     A,#0xe0
        JZ      ??usbfwSetupHandler_11
        ADD     A,#-0x20
        JNZ     $+5
        LJMP    ??usbfwSetupHandler_12 & 0xFFFF
        ADD     A,#-0x20
        JZ      ??usbfwSetupHandler_13
        ADD     A,#-0x40
        JZ      ??usbfwSetupHandler_14
        ADD     A,#-0x20
        JNZ     $+5
        LJMP    ??usbfwSetupHandler_15 & 0xFFFF
        ADD     A,#-0x20
        JZ      ??usbfwSetupHandler_16
        LJMP    ??usbfwSetupHandler_17 & 0xFFFF
//  137 
//  138             // Standard requests with data from the host (OUT)
//  139          case RT_STD_OUT:
//  140             switch (usbSetupHeader.request) {
??usbfwSetupHandler_11:
        INC     DPTR
        MOVX    A,@DPTR
        DEC     A
        JZ      ??usbfwSetupHandler_18
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_19
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_20
        ADD     A,#-0x4
        JZ      ??usbfwSetupHandler_21
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_22
        SJMP    ??usbfwSetupHandler_17
//  141             case SET_ADDRESS:       usbsrSetAddress(); break;
??usbfwSetupHandler_20:
        ; Setup parameters for call to function usbsrSetAddress
        LCALL   ??usbsrSetAddress?relay; Banked call to: usbsrSetAddress
//  142             case SET_FEATURE:       usbsrSetFeature(); break;
//  143             case CLEAR_FEATURE:     usbsrClearFeature(); break;
//  144             case SET_CONFIGURATION: usbsrSetConfiguration(); break;
//  145             case SET_INTERFACE:     usbsrSetInterface(); break;
//  146             case SET_DESCRIPTOR:    /*usbsrHookSetDescriptor(); break; - unsupported */
//  147             default:                usbfwData.ep0Status = EP_STALL; break;
//  148             }
//  149             break;
//  150 
//  151             // Standard requests with data to the host (IN)
//  152          case RT_STD_IN:
//  153             switch (usbSetupHeader.request) {
//  154             case GET_STATUS:        usbsrGetStatus(); break;
//  155             case GET_DESCRIPTOR:    usbsrGetDescriptor(); break;
//  156             case GET_CONFIGURATION: usbsrGetConfiguration(); break;
//  157             case GET_INTERFACE:     usbsrGetInterface(); break;
//  158             case SYNCH_FRAME:       /*usbsrHookSynchFrame(); break; - unsupported */
//  159             default:                usbfwData.ep0Status = EP_STALL; break;
//  160             }
//  161             break;
//  162 
//  163             // Vendor requests
//  164          case RT_VEND_OUT:
//  165             ProcessFunc = usbvrHookProcessOut; usbvrHookProcessOut();
//  166             break;
//  167          case RT_VEND_IN:
//  168             ProcessFunc = usbvrHookProcessIn; usbvrHookProcessIn();
//  169             break;
//  170 
//  171             // Class requests
//  172          case RT_CLASS_OUT:
//  173             ProcessFunc = usbcrHookProcessOut; usbcrHookProcessOut();
//  174             break;
//  175          case RT_CLASS_IN:
//  176             ProcessFunc = usbcrHookProcessIn; usbcrHookProcessIn();
//  177             break;
//  178 
//  179             // Unrecognized request: Stall the endpoint
//  180          default:
//  181             usbfwData.ep0Status = EP_STALL;
//  182             break;
//  183          }
//  184 
//  185          // Arm/stall the endpoint
//  186          USBCS0 = (usbfwData.ep0Status == EP_STALL) ? (USBCS0_CLR_OUTPKT_RDY | USBCS0_SEND_STALL) : USBCS0_CLR_OUTPKT_RDY;
??usbfwSetupHandler_23:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbfwSetupHandler_24
??usbfwSetupHandler_25:
        MOV     A,#0x60
        SJMP    ??usbfwSetupHandler_26
??usbfwSetupHandler_19:
        ; Setup parameters for call to function usbsrSetFeature
        LCALL   ??usbsrSetFeature?relay; Banked call to: usbsrSetFeature
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_18:
        ; Setup parameters for call to function usbsrClearFeature
        LCALL   ??usbsrClearFeature?relay; Banked call to: usbsrClearFeature
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_21:
        ; Setup parameters for call to function usbsrSetConfiguration
        LCALL   ??usbsrSetConfiguration?relay; Banked call to: usbsrSetConfiguration
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_22:
        ; Setup parameters for call to function usbsrSetInterface
        LCALL   ??usbsrSetInterface?relay; Banked call to: usbsrSetInterface
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_14:
        INC     DPTR
        MOVX    A,@DPTR
        JZ      ??usbfwSetupHandler_27
        ADD     A,#-0x6
        JZ      ??usbfwSetupHandler_28
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_29
        ADD     A,#-0x2
        JZ      ??usbfwSetupHandler_30
        SJMP    ??usbfwSetupHandler_17
??usbfwSetupHandler_27:
        ; Setup parameters for call to function usbsrGetStatus
        LCALL   ??usbsrGetStatus?relay; Banked call to: usbsrGetStatus
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_28:
        ; Setup parameters for call to function usbsrGetDescriptor
        LCALL   ??usbsrGetDescriptor?relay; Banked call to: usbsrGetDescriptor
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_29:
        ; Setup parameters for call to function usbsrGetConfiguration
        LCALL   ??usbsrGetConfiguration?relay; Banked call to: usbsrGetConfiguration
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_30:
        ; Setup parameters for call to function usbsrGetInterface
        LCALL   ??usbsrGetInterface?relay; Banked call to: usbsrGetInterface
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_13:
        MOV     ??ProcessFunc+0x0,#??usbvrHookProcessOut?relay & 0xff
        MOV     ??ProcessFunc+0x1,#(??usbvrHookProcessOut?relay >> 8) & 0xff
        ; Setup parameters for call to function usbvrHookProcessOut
        LCALL   ??usbvrHookProcessOut?relay; Banked call to: usbvrHookProcessOut
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_16:
        MOV     ??ProcessFunc+0x0,#??usbvrHookProcessIn?relay & 0xff
        MOV     ??ProcessFunc+0x1,#(??usbvrHookProcessIn?relay >> 8) & 0xff
        ; Setup parameters for call to function usbvrHookProcessIn
        LCALL   ??usbvrHookProcessIn?relay; Banked call to: usbvrHookProcessIn
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_12:
        MOV     ??ProcessFunc+0x0,#??usbcrHookProcessOut?relay & 0xff
        MOV     ??ProcessFunc+0x1,#(??usbcrHookProcessOut?relay >> 8) & 0xff
        ; Setup parameters for call to function usbcrHookProcessOut
        LCALL   ??usbcrHookProcessOut?relay; Banked call to: usbcrHookProcessOut
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_15:
        MOV     ??ProcessFunc+0x0,#??usbcrHookProcessIn?relay & 0xff
        MOV     ??ProcessFunc+0x1,#(??usbcrHookProcessIn?relay >> 8) & 0xff
        ; Setup parameters for call to function usbcrHookProcessIn
        LCALL   ??usbcrHookProcessIn?relay; Banked call to: usbcrHookProcessIn
        SJMP    ??usbfwSetupHandler_23
??usbfwSetupHandler_17:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_25
//  187       }
//  188    }
??usbfwSetupHandler_24:
        MOV     A,#0x40
??usbfwSetupHandler_26:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  189 
//  190    // Transmit IN packets
//  191    if (usbfwData.ep0Status == EP_TX) {
??usbfwSetupHandler_10:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_31
//  192       controlReg = USBCS0_INPKT_RDY;
        MOV     R7,#0x2
//  193 
//  194       // The last frame should contain 0 to (EP0_PACKET_SIZE - 1) bytes
//  195       if (usbSetupData.bytesLeft < EP0_PACKET_SIZE) {
        LCALL   ?Subroutine15 & 0xFFFF
??CrossCallReturnLabel_39:
        CLR     C
        MOV     A,R0
        SUBB    A,#0x20
        MOV     A,R1
        SUBB    A,#0x0
        JNC     ??usbfwSetupHandler_32
//  196          bytesNow = usbSetupData.bytesLeft;
        MOV     A,R0
        MOV     ?V2,A
//  197          controlReg |= USBCS0_DATA_END;
        MOV     R7,#0xa
        SJMP    ??usbfwSetupHandler_33
//  198 
//  199          // All other packets should have the maximum length
//  200       } else {
//  201          bytesNow = EP0_PACKET_SIZE;
??usbfwSetupHandler_32:
        MOV     ?V2,#0x20
//  202       }
//  203 
//  204       // Load the FIFO and move the pointer
//  205       usbfwWriteFifo(&USBF0, bytesNow, usbSetupData.pBuffer);
??usbfwSetupHandler_33:
        ; Setup parameters for call to function usbfwWriteFifo
        MOV     DPTR,#usbSetupData
        LCALL   ?PUSH_XSTACK8_X_THREE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R1,?V2
        MOV     R2,#0x20
        MOV     R3,#0x62
        LCALL   ??usbfwWriteFifo?relay; Banked call to: usbfwWriteFifo
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  206       usbSetupData.pBuffer += bytesNow;
        MOV     ?V0,?V2
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_48:
        MOV     A,R1
        ADD     A,?V0
        LCALL   ?Subroutine22 & 0xFFFF
//  207       usbSetupData.bytesLeft -= bytesNow;
??CrossCallReturnLabel_29:
        LCALL   ?Subroutine18 & 0xFFFF
//  208 
//  209       // Arm the FIFO (even for a zero-length packet)
//  210       USBCS0 = controlReg;
??CrossCallReturnLabel_21:
        MOV     A,R7
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  211 
//  212       // Make a call to the appropriate request handler when done
//  213       if (bytesNow < EP0_PACKET_SIZE) {
        MOV     A,?V2
        CLR     C
        SUBB    A,#0x20
        JNC     ??usbfwSetupHandler_7
//  214          if (ProcessFunc) ProcessFunc();
??usbfwSetupHandler_8:
        MOV     A,??ProcessFunc+0x0
        ORL     A,??ProcessFunc+0x1
        JZ      ??usbfwSetupHandler_34
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  215          usbfwData.ep0Status = EP_IDLE;
??usbfwSetupHandler_34:
        MOV     DPTR,#usbfwData + 7
        CLR     A
        MOVX    @DPTR,A
        SJMP    ??usbfwSetupHandler_7
//  216       }
//  217 
//  218    // Let the application handle the transmission
//  219    } else if (usbfwData.ep0Status == EP_MANUAL_TX) {
??usbfwSetupHandler_31:
        MOV     A,#0x5
        XRL     A,R0
        JNZ     ??usbfwSetupHandler_7
//  220       ProcessFunc();
        ; Setup parameters for indirect call
        MOV     DPL,??ProcessFunc+0x0
        MOV     DPH,??ProcessFunc+0x1
        LCALL   ?CALL_IND
//  221    }
//  222 
//  223    // Restore the old index setting
//  224    USBFW_SELECT_ENDPOINT(oldEndpoint);
??usbfwSetupHandler_7:
        MOV     A,R6
        MOV     DPTR,#0x620e
          CFI EndBlock cfiBlock91
        REQUIRE ?Subroutine3
        ; // Fall through to label ?Subroutine3
//  225 
//  226 } // usbfwSetupHandler

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
          CFI Block cfiBlock92 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOVX    @DPTR,A
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock92

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine22:
          CFI Block cfiCond93 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_28
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond94 Using cfiCommon0
          CFI (cfiCond94) Function usbfwSetupHandler
          CFI (cfiCond94) Conditional ??CrossCallReturnLabel_29
          CFI (cfiCond94) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond94) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond94) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond94) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond94) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond94) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond94) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond94) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond94) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond94) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond94) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond94) CFA_SP SP+-2
          CFI (cfiCond94) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker95 Using cfiCommon1
          CFI (cfiPicker95) NoFunction
          CFI (cfiPicker95) Picker
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        MOV     DPTR,#usbSetupData
        MOV     A,R1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        RET
          CFI EndBlock cfiCond93
          CFI EndBlock cfiCond94
          CFI EndBlock cfiPicker95

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine18:
          CFI Block cfiCond96 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_20
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond97 Using cfiCommon0
          CFI (cfiCond97) Function usbfwSetupHandler
          CFI (cfiCond97) Conditional ??CrossCallReturnLabel_21
          CFI (cfiCond97) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond97) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond97) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond97) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond97) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond97) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond97) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond97) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond97) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond97) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond97) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond97) CFA_SP SP+-2
          CFI (cfiCond97) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker98 Using cfiCommon1
          CFI (cfiPicker98) NoFunction
          CFI (cfiPicker98) Picker
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x0
        MOVX    @DPTR,A
        RET
          CFI EndBlock cfiCond96
          CFI EndBlock cfiCond97
          CFI EndBlock cfiPicker98
//  227 
//  228 
//  229 
//  230 
//  231 /** \brief Changes the state of endpoint 1-5 IN/OUT
//  232  *
//  233  * This is an internal function used by the library.
//  234  *
//  235  * \param[in]       status
//  236  *     The new status for each endpoint
//  237  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  238 void usbfwSetAllEpStatus(EP_STATUS status)
usbfwSetAllEpStatus:
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function usbfwSetAllEpStatus
        CODE
//  239 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  240    uint8 n;
//  241    for (n = 0; n < sizeof(usbfwData.pEpInStatus); n++)
        MOV     R0,#0x0
//  242        usbfwData.pEpInStatus[n] = status;
??usbfwSetAllEpStatus_0:
        MOV     A,#(usbfwData + 8) & 0xff
        ADD     A,R0
        MOV     DPL,A
        CLR     A
        ADDC    A,#((usbfwData + 8) >> 8) & 0xff
        MOV     DPH,A
        MOV     A,R1
        MOVX    @DPTR,A
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x5
        JC      ??usbfwSetAllEpStatus_0
//  243    for (n = 0; n < sizeof(usbfwData.pEpOutStatus); n++)
        MOV     R0,#0x0
//  244        usbfwData.pEpOutStatus[n] = status;
??usbfwSetAllEpStatus_1:
        MOV     A,#(usbfwData + 13) & 0xff
        ADD     A,R0
        MOV     DPL,A
        CLR     A
        ADDC    A,#((usbfwData + 13) >> 8) & 0xff
        MOV     DPH,A
        MOV     A,R1
        MOVX    @DPTR,A
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x5
        JC      ??usbfwSetAllEpStatus_1
//  245 } // usbfwSetAllEpStatus
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock99
//  246 
//  247 
//  248 
//  249 
//  250 /** \brief Reads from the selected OUT endpoint FIFO, without using DMA
//  251  *
//  252  * The FIFO must be re-armed after reading it empty (using the \ref USBFW_ARM_OUT_ENDPOINT() macro). This
//  253  * is not necessary when flushing the FIFO.
//  254  *
//  255  * \param[in]       *pFifo
//  256  *     Pointer to the FIFO (\c &USBFx)
//  257  * \param[in]       count
//  258  *     The number of bytes to read
//  259  * \param[in]       *pData
//  260  *     A pointer to the storage location for the read data (in any memory space)
//  261  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  262 void usbfwReadFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
usbfwReadFifo:
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function usbfwReadFifo
        CODE
//  263 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R1
        MOV     R0,A
//  264    uint8 __generic *pTemp = pData;
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine31_0 & 0xFFFF
//  265    if (count) {
??CrossCallReturnLabel_45:
        MOV     A,R0
        JZ      ??usbfwReadFifo_0
//  266       do {
//  267          *(pTemp++) = *pFifo;
??usbfwReadFifo_1:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        LCALL   ?C_GPTR_STORE
        MOV     A,R1
        ADD     A,#0x1
        INC     R1
        CLR     A
        ADDC    A,R2
        MOV     R2,A
//  268       } while (--count);
        DJNZ    R0,??usbfwReadFifo_1
          CFI EndBlock cfiBlock100
//  269    }
//  270 } // usbfwReadFifo
??usbfwReadFifo_0:
        REQUIRE ?Subroutine4
        ; // Fall through to label ?Subroutine4

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
          CFI Block cfiBlock101 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock101

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
          CFI Block cfiCond102 Using cfiCommon0
          CFI Function usbfwSetupHandler
          CFI Conditional ??CrossCallReturnLabel_47
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond103 Using cfiCommon0
          CFI (cfiCond103) Function usbfwSetupHandler
          CFI (cfiCond103) Conditional ??CrossCallReturnLabel_48
          CFI (cfiCond103) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond103) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond103) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond103) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond103) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond103) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond103) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond103) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond103) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond103) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond103) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond103) CFA_SP SP+-2
          CFI (cfiCond103) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker104 Using cfiCommon1
          CFI (cfiPicker104) NoFunction
          CFI (cfiPicker104) Picker
        MOV     DPTR,#usbSetupData
          CFI EndBlock cfiCond102
          CFI EndBlock cfiCond103
          CFI EndBlock cfiPicker104
        REQUIRE ??Subroutine31_0
        ; // Fall through to label ??Subroutine31_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine31_0:
          CFI Block cfiCond105 Using cfiCommon0
          CFI Function usbfwReadFifo
          CFI Conditional ??CrossCallReturnLabel_45
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond106 Using cfiCommon0
          CFI (cfiCond106) Function usbfwWriteFifo
          CFI (cfiCond106) Conditional ??CrossCallReturnLabel_46
          CFI (cfiCond106) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond106) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond106) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond106) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond106) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond106) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond106) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond106) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond106) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond106) CFA_SP SP+-2
          CFI (cfiCond106) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond107 Using cfiCommon0
          CFI (cfiCond107) Function usbfwSetupHandler
          CFI (cfiCond107) Conditional ??CrossCallReturnLabel_47
          CFI (cfiCond107) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond107) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond107) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond107) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond107) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond107) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond107) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond107) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond107) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond107) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond107) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond107) CFA_SP SP+-2
          CFI (cfiCond107) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond108 Using cfiCommon0
          CFI (cfiCond108) Function usbfwSetupHandler
          CFI (cfiCond108) Conditional ??CrossCallReturnLabel_48
          CFI (cfiCond108) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond108) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond108) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond108) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond108) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond108) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond108) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond108) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond108) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond108) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond108) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond108) CFA_SP SP+-2
          CFI (cfiCond108) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker109 Using cfiCommon1
          CFI (cfiPicker109) NoFunction
          CFI (cfiPicker109) Picker
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
          CFI EndBlock cfiCond105
          CFI EndBlock cfiCond106
          CFI EndBlock cfiCond107
          CFI EndBlock cfiCond108
          CFI EndBlock cfiPicker109
        REQUIRE ??Subroutine32_0
        ; // Fall through to label ??Subroutine32_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine32_0:
          CFI Block cfiCond110 Using cfiCommon0
          CFI Function HalFlashRead
          CFI Conditional ??CrossCallReturnLabel_41
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond111 Using cfiCommon0
          CFI (cfiCond111) Function usbdpFindNext
          CFI (cfiCond111) Conditional ??CrossCallReturnLabel_42
          CFI (cfiCond111) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond111) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond111) CFA_SP SP+-7
          CFI Block cfiCond112 Using cfiCommon0
          CFI (cfiCond112) Function usbsrGetDescriptor
          CFI (cfiCond112) Conditional ??CrossCallReturnLabel_43
          CFI (cfiCond112) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond112) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond112) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond112) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond112) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond112) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond112) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond112) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond112) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond112) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond112) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond112) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond112) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond112) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond112) CFA_SP SP+-2
          CFI (cfiCond112) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond113 Using cfiCommon0
          CFI (cfiCond113) Function usbsrGetDescriptor
          CFI (cfiCond113) Conditional ??CrossCallReturnLabel_44
          CFI (cfiCond113) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond113) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond113) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond113) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond113) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond113) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond113) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond113) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond113) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond113) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond113) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond113) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond113) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond113) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond113) CFA_SP SP+-2
          CFI (cfiCond113) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond114 Using cfiCommon0
          CFI (cfiCond114) Function usbfwReadFifo
          CFI (cfiCond114) Conditional ??CrossCallReturnLabel_45
          CFI (cfiCond114) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond114) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond114) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond114) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond114) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond114) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond114) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond114) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond114) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond114) CFA_SP SP+-2
          CFI (cfiCond114) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond115 Using cfiCommon0
          CFI (cfiCond115) Function usbfwWriteFifo
          CFI (cfiCond115) Conditional ??CrossCallReturnLabel_46
          CFI (cfiCond115) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond115) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond115) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond115) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond115) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond115) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond115) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond115) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond115) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond115) CFA_SP SP+-2
          CFI (cfiCond115) CFA_XSP16 add(XSP16, 9)
          CFI Block cfiCond116 Using cfiCommon0
          CFI (cfiCond116) Function usbfwSetupHandler
          CFI (cfiCond116) Conditional ??CrossCallReturnLabel_47
          CFI (cfiCond116) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond116) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond116) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond116) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond116) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond116) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond116) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond116) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond116) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond116) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond116) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond116) CFA_SP SP+-2
          CFI (cfiCond116) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond117 Using cfiCommon0
          CFI (cfiCond117) Function usbfwSetupHandler
          CFI (cfiCond117) Conditional ??CrossCallReturnLabel_48
          CFI (cfiCond117) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond117) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond117) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond117) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond117) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond117) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond117) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond117) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond117) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond117) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond117) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond117) CFA_SP SP+-2
          CFI (cfiCond117) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker118 Using cfiCommon1
          CFI (cfiPicker118) NoFunction
          CFI (cfiPicker118) Picker
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        RET
          CFI EndBlock cfiCond110
          CFI EndBlock cfiCond111
          CFI EndBlock cfiCond112
          CFI EndBlock cfiCond113
          CFI EndBlock cfiCond114
          CFI EndBlock cfiCond115
          CFI EndBlock cfiCond116
          CFI EndBlock cfiCond117
          CFI EndBlock cfiPicker118
//  271 
//  272 
//  273 
//  274 
//  275 /** \brief Writes to the selected IN endpoint FIFO, without using DMA
//  276  *
//  277  * Note that the FIFO must be armed in order to be transmitted (using the \ref USBFW_ARM_IN_ENDPOINT()
//  278  * macro).
//  279  *
//  280  * \param[in]       *pFifo
//  281  *     Pointer to the FIFO (\c &USBFx)
//  282  * \param[in]       count
//  283  *     The number of bytes to write
//  284  * \param[in]       *pData
//  285  *     A pointer to the data to be written (from any memory space)
//  286  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  287 void usbfwWriteFifo(uint8 volatile __xdata *pFifo, uint8 count, void __generic *pData)
usbfwWriteFifo:
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function usbfwWriteFifo
        CODE
//  288 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R1
        MOV     R0,A
//  289    uint8 __generic *pTemp = pData;
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        LCALL   ??Subroutine31_0 & 0xFFFF
//  290    if (count) {
??CrossCallReturnLabel_46:
        MOV     A,R0
        JZ      ??usbfwWriteFifo_0
//  291       do {
//  292          *pFifo = *(pTemp++);
??usbfwWriteFifo_1:
        LCALL   ?C_GPTR_LOAD
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     A,R1
        ADD     A,#0x1
        INC     R1
        CLR     A
        ADDC    A,R2
        MOV     R2,A
//  293       } while (--count);
        DJNZ    R0,??usbfwWriteFifo_1
//  294    }
//  295 } // usbfwWriteFifo
??usbfwWriteFifo_0:
        SJMP    ?Subroutine4
          CFI EndBlock cfiBlock119
//  296 
//  297 
//  298 /// @}
//  299 /*
//  300 +------------------------------------------------------------------------------
//  301 |  Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
//  302 |
//  303 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  304 |  granted under the terms of a software license agreement between the user who
//  305 |  downloaded the software, his/her employer (which must be your employer) and
//  306 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  307 |  unless you agree to abide by the terms of the License. The License limits
//  308 |  your use, and you acknowledge, that the Software may not be modified, copied
//  309 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  310 |  solely and exclusively in conjunction with a Texas Instruments radio
//  311 |  frequency transceiver, which is integrated into your product. Other than for
//  312 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  313 |  works of, modify, distribute, perform, display or sell this Software and/or
//  314 |  its documentation for any purpose.
//  315 |
//  316 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  317 |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  318 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  319 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  320 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  321 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  322 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  323 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  324 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  325 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  326 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  327 |
//  328 |  Should you have any questions regarding your right to use this Software,
//  329 |  contact Texas Instruments Incorporated at www.TI.com.
//  330 |
//  331 +------------------------------------------------------------------------------
//  332 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_interrupt.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_interrupt.c
//    4 
//    5     Description:  USB library interrupt initialisation and ISR.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_interrupt
//   10 /// @{
//   11 #define USBINTERRUPT_C ///< Modifies the behavior of "EXTERN" in usb_interrupt.h
//   12 #include "usb_firmware_library_headers.h"
//   13 #include "usb_board_cfg.h"
//   14 #include "hal_flash.h"
//   15 
//   16 /** \brief Initializes the \ref module_usb_interrupt module
//   17  *
//   18  * This function should be called after the \ref module_usb_framework module has been initialized.
//   19  * Use interrupt group priority control (refer to the CC2531 datasheet) to adjust the priority of the
//   20  * USB interrupt relative to other interrupts.
//   21  *
//   22  * \param[in]       irqMask
//   23  *     A bit mask containing USBIRQ_EVENT bits for all events that shall be reported
//   24  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   25 void usbirqInit(uint16 irqMask)
usbirqInit:
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function usbirqInit
        CODE
//   26 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   27     // Initialize variables
//   28     usbirqData.eventMask = 0x0000;
        MOV     usbirqData+0x0,#0x0
        MOV     usbirqData+0x1,#0x0
//   29     usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//   30     usbirqData.irqMask = irqMask;
        MOV     usbirqData + 3+0x0,R2
        MOV     usbirqData + 3+0x1,R3
//   31 
//   32     // Select which IRQ flags to handle
//   33     USBCIE = irqMask;
        MOV     A,R2
        MOV     DPTR,#0x620b
        MOVX    @DPTR,A
//   34     USBIIE = irqMask >> 4;
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#0x6207
        MOVX    @DPTR,A
//   35     USBOIE = (irqMask >> 9) & 0x3E;
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        ANL     A,#0x3e
        MOV     DPTR,#0x6209
        MOVX    @DPTR,A
//   36 
//   37     HAL_USB_INT_CLEAR();
        LJMP    ?Subroutine1 & 0xFFFF
          CFI EndBlock cfiBlock120
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//   38     HAL_USB_INT_ENABLE();
//   39 
//   40 } // usbirqInit
//   41 
//   42 
//   43 
//   44 /** \brief USB interrupt handler
//   45  *
//   46  * Clears the P2 interrupt flag and converts all USB interrupt flags into events.
//   47  * The interrupt also lets \ref usbsuspEnter() break from the suspend loop.
//   48  */
//   49 #if defined HAL_SB_BOOT_CODE

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   50 void usbirqHandler(void)
usbirqHandler:
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function usbirqHandler
        CODE
//   51 #else
//   52 #pragma vector=P2INT_VECTOR
//   53 __interrupt void usbirqHandler(void)
//   54 #endif
//   55 {
        FUNCALL usbirqHandler, usbirqHookProcessEvents
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   56    uint8 usbcif;
//   57 
//   58    // First make sure that the crystal oscillator is stable
//   59    while (!CC2530_IS_XOSC_STABLE());
??usbirqHandler_0:
        MOV     A,0x9d
        MOV     C,0xE0 /* A   */.6
        JNC     ??usbirqHandler_0
//   60 
//   61    // Special handling for reset interrupts
//   62    usbcif = USBCIF;
        MOV     DPTR,#0x6206
        MOVX    A,@DPTR
        MOV     R2,A
//   63    if (usbcif & USBCIF_RSTIF) {
        MOV     C,0xE0 /* A   */.2
        JNC     ??usbirqHandler_1
//   64 
//   65        // All interrupts (except suspend) are by default enabled by hardware, so
//   66        // re-initialize the enable bits to avoid unwanted interrupts
//   67        USBCIE = usbirqData.irqMask;
        MOV     R0,usbirqData + 3+0x0
        MOV     A,R0
        MOV     DPTR,#0x620b
        MOVX    @DPTR,A
//   68        USBIIE = usbirqData.irqMask >> 4;
        MOV     ?V0,A
        MOV     ?V1,usbirqData + 3+0x1
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        MOV     DPTR,#0x6207
        MOVX    @DPTR,A
//   69        USBOIE = (usbirqData.irqMask >> 9) & 0x3E;
        MOV     ?V0,usbirqData + 3+0x0
        MOV     ?V1,usbirqData + 3+0x1
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?US_SHR
        MOV     A,?V0
        ANL     A,#0x3e
        MOV     DPTR,#0x6209
        MOVX    @DPTR,A
//   70 
//   71        // Enable suspend mode when suspend signaling is detected on the bus
//   72        USBPOW |= USBPOW_SUSPEND_EN;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
//   73    }
//   74 
//   75    // Record events (keeping existing)
//   76    usbirqData.eventMask |= (uint16) usbcif;
??usbirqHandler_1:
        MOV     R0,#usbirqData
        MOV     A,R2
        ORL     A,@R0
        MOV     @R0,A
//   77    usbirqData.eventMask |= (uint16) USBIIF << 4;
        MOV     DPTR,#0x6202
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,#0x4
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,#usbirqData
        MOV     A,?V0
        ORL     A,@R0
        MOV     @R0,A
        INC     R0
        MOV     A,?V1
        ORL     A,@R0
        MOV     @R0,A
//   78    usbirqData.eventMask |= (uint16) USBOIF << 9;
        MOV     DPTR,#0x6204
        MOVX    A,@DPTR
        MOV     ?V0,A
        MOV     ?V1,#0x0
        MOV     A,#0x9
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     R0,#usbirqData + 1
        MOV     A,?V1
        ORL     A,@R0
        MOV     @R0,A
//   79 
//   80    // If we get a suspend event, we should always enter suspend mode. We must,
//   81    // however be sure that we exit the suspend loop upon resume or reset
//   82    // signaling.
//   83    if (usbcif & USBCIF_SUSPENDIF) {
        MOV     A,R2
        MOV     C,0xE0 /* A   */.0
        JNC     ??usbirqHandler_2
//   84       usbirqData.inSuspend = TRUE;
        MOV     usbirqData + 2,#0x1
//   85    }
//   86    if (usbcif & (USBCIF_RSTIF | USBCIF_RESUMEIF)) {
??usbirqHandler_2:
        MOV     A,#0x6
        ANL     A,R2
        JZ      ??usbirqHandler_3
//   87       usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//   88    }
//   89    if (P2IFG & P2IFG_DPIF) {
??usbirqHandler_3:
        MOV     A,0x8b
        MOV     C,0xE0 /* A   */.5
        JNC     ??usbirqHandler_4
//   90       // Resume interrupt detected on D+ line while in suspend
//   91       P2IFG = (P2IFG_DPIF ^ 0xFF);
        MOV     0x8b,#-0x21
//   92       usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//   93    }
//   94 
//   95    // Handle event which need immediate processing
//   96    usbirqHookProcessEvents();
??usbirqHandler_4:
        ; Setup parameters for call to function usbirqHookProcessEvents
        LCALL   ??usbirqHookProcessEvents?relay; Banked call to: usbirqHookProcessEvents
//   97 
//   98    // Clear the interrupt
//   99    HAL_USB_INT_CLEAR();
        LJMP    ?Subroutine1 & 0xFFFF
          CFI EndBlock cfiBlock121
        REQUIRE SLEEPSTA
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//  100 
//  101 } // usbirqHandler
//  102 
//  103 //@}
//  104 
//  105 /*
//  106 +------------------------------------------------------------------------------
//  107 |  Copyright 2008-2012 Texas Instruments Incorporated. All rights reserved.
//  108 |
//  109 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  110 |  granted under the terms of a software license agreement between the user who
//  111 |  downloaded the software, his/her employer (which must be your employer) and
//  112 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  113 |  unless you agree to abide by the terms of the License. The License limits
//  114 |  your use, and you acknowledge, that the Software may not be modified, copied
//  115 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  116 |  solely and exclusively in conjunction with a Texas Instruments radio
//  117 |  frequency transceiver, which is integrated into your product. Other than for
//  118 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  119 |  works of, modify, distribute, perform, display or sell this Software and/or
//  120 |  its documentation for any purpose.
//  121 |
//  122 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  123 |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  124 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  125 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  126 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  127 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  128 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  129 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  130 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  131 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  132 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  133 |
//  134 |  Should you have any questions regarding your right to use this Software,
//  135 |  contact Texas Instruments Incorporated at www.TI.com.
//  136 |
//  137 +------------------------------------------------------------------------------
//  138 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\library\usb_standard_requests.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_standard_request.c
//    4 
//    5     Description:  Handle USB standard requests.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_standard_requests
//   10 /// @{
//   11 #include "usb_firmware_library_headers.h"
//   12 #include "hal_types.h"
//   13 #include "hal_board.h"
//   14 
//   15 
//   16 
//   17 /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
//   18  *
//   19  * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
//   20  * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
//   21  * changed with the SET_FEATURE and CLEAR_FEATURE requests.
//   22  *
//   23  * <b>Parameters</b>:
//   24  * - VALUE: Always 0
//   25  * - INDEX: Depends upon the recipient:
//   26  *     - DEVICE: Always 0
//   27  *     - INTERFACE: Interface number
//   28  *     - ENDPOINT: Endpoint address
//   29  * - LENGTH: Always 2
//   30  *
//   31  * <b>Data (IN)</b>:
//   32  * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
//   33  * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
//   34  * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
//   35  * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
//   36  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   37 void usbsrGetStatus(void)
usbsrGetStatus:
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function usbsrGetStatus
        CODE
//   38 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   39    uint8 endpoint;
//   40    static uint16 __xdata status;
//   41 
//   42    // Common sanity check
//   43    if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_59:
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrGetStatus_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetStatus_1:
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   44       usbfwData.ep0Status = EP_STALL;
//   45 
//   46    // Return status for device, interface, or endpoint
//   47    } else {
//   48       switch (usbSetupHeader.requestType) {
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ADD     A,#-0x80
        JZ      ??usbsrGetStatus_2
        DEC     A
        JZ      ??usbsrGetStatus_3
        DEC     A
        JZ      ??usbsrGetStatus_4
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   49 
//   50          // Device status:
//   51          //     Bit 0: Self powered
//   52          //     Bit 1: Remote wake-up allowed
//   53       case RT_IN_DEVICE:
//   54 
//   55          // Sanity check
//   56          if (LO_UINT16(usbSetupHeader.index)) {
??usbsrGetStatus_2:
        MOV     A,R0
        JZ      $+5
        LJMP    ??usbsrGetStatus_0 & 0xFFFF
//   57             usbfwData.ep0Status = EP_STALL;
//   58 
//   59          // Get the bit values from the USBFW_DATA struct
//   60          } else {
//   61 
//   62             // Self powered?
//   63             status = usbfwData.selfPowered ? 0x0001 : 0x0000;
        MOV     DPTR,#usbfwData + 19
        MOVX    A,@DPTR
        JZ      ??usbsrGetStatus_5
        MOV     R0,#0x1
        SJMP    ??usbsrGetStatus_6
??usbsrGetStatus_5:
        MOV     R0,#0x0
??usbsrGetStatus_6:
        MOV     DPTR,#??status
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//   64 
//   65             // Remote wakeup?
//   66             if (usbfwData.remoteWakeup) status |= 0x0002;
        MOV     DPTR,#usbfwData + 18
        MOVX    A,@DPTR
        JZ      ??usbsrGetStatus_7
        MOV     DPTR,#??status
        MOVX    A,@DPTR
        ORL     A,#0x2
??usbsrGetStatus_8:
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??usbsrGetStatus_9:
        MOVX    @DPTR,A
//   67          }
//   68          break;
//   69 
//   70          // Interface status:
//   71          //     All bits are reserved
//   72       case RT_IN_INTERFACE:
//   73 
//   74          // Sanity check
//   75          if (usbfwData.usbState != DEV_CONFIGURED) {
//   76             usbfwData.ep0Status = EP_STALL;
//   77          } else {
//   78             status = 0x0000;
//   79          }
//   80          break;
//   81 
//   82          // Endpoint status:
//   83          //     Bit 0: Endpoint halted
//   84       case RT_IN_ENDPOINT:
//   85          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
//   86 
//   87          // Sanity check
//   88          if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
//   89             usbfwData.ep0Status = EP_STALL;
//   90 
//   91          // Translate endpoint address to status index and return the status
//   92          } else {
//   93 
//   94             // IN
//   95             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
//   96                status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
//   97 
//   98             // OUT
//   99             } else {
//  100                status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
//  101             }
//  102          }
//  103          break;
//  104 
//  105       default:
//  106          usbfwData.ep0Status = EP_STALL;
//  107          break;
//  108       }
//  109 
//  110       if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetStatus_7:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetStatus_10
//  111          // Send it
//  112          usbSetupData.pBuffer = (uint8 __generic *)&status;
        MOV     DPTR,#usbSetupData
        MOV     A,#??status & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(??status >> 8) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  113          usbSetupData.bytesLeft = 2;
        INC     DPTR
        MOV     A,#0x2
        LCALL   ?Subroutine26 & 0xFFFF
//  114          usbfwData.ep0Status = EP_TX;
//  115       }
??CrossCallReturnLabel_34:
        MOVX    @DPTR,A
//  116    }
//  117 } // usbsrGetStatus
??usbsrGetStatus_10:
        LJMP    ??Subroutine27_0 & 0xFFFF
??usbsrGetStatus_3:
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
        MOV     DPTR,#??status
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        SJMP    ??usbsrGetStatus_9
??usbsrGetStatus_4:
        MOV     A,R0
        ANL     A,#0x7f
        MOV     ?V0,A
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
        MOV     A,?V0
        CLR     C
        SUBB    A,#0x6
        JNC     ??usbsrGetStatus_0
        MOV     A,#usbfwData & 0xff
        ADD     A,?V0
        MOV     DPL,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     DPH,A
        MOV     A,R0
        ANL     A,#0x80
        JZ      ??usbsrGetStatus_11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrGetStatus_12
??usbsrGetStatus_13:
        MOV     R0,#0x1
        SJMP    ??usbsrGetStatus_14
??usbsrGetStatus_12:
        MOV     R0,#0x0
??usbsrGetStatus_14:
        MOV     DPTR,#??status
        MOV     A,R0
        SJMP    ??usbsrGetStatus_8
??usbsrGetStatus_11:
        MOV     A,DPL
        ADD     A,#0xc
        MOV     DPL,A
        JNC     ??usbsrGetStatus_15
        INC     DPH
??usbsrGetStatus_15:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrGetStatus_12
        SJMP    ??usbsrGetStatus_13
??usbsrGetStatus_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_34
          CFI EndBlock cfiBlock122

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
??status:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  118 
//  119 
//  120 
//  121 
//  122 /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
//  123  *
//  124  * This function either sets or clears the specified feature on the specified recipient.
//  125  *
//  126  * \param[in]       set
//  127  *     When TRUE, the feature is set. When FALSE, the feature is cleared.
//  128  *
//  129  * \return
//  130  *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
//  131  *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
//  132  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  133 static uint8 ChangeFeature(uint8 set)
??ChangeFeature:
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function ??ChangeFeature
        CODE
//  134 {
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
//  135    uint8 endpoint;
//  136 
//  137    // Sanity check
//  138    if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_51:
        JZ      $+5
        LJMP    ??ChangeFeature_1 & 0xFFFF
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??ChangeFeature_2
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_52:
        JZ      $+5
        LJMP    ??ChangeFeature_1 & 0xFFFF
//  139       usbfwData.ep0Status = EP_STALL;
//  140 
//  141       // Handle based on recipient
//  142    } else {
//  143       switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
??ChangeFeature_2:
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ANL     A,#0x1f
        JZ      ??ChangeFeature_3
        DEC     A
        JZ      ??ChangeFeature_4
        DEC     A
        JZ      ??ChangeFeature_5
        LJMP    ??ChangeFeature_1 & 0xFFFF
//  144 
//  145       // Device
//  146       case RT_RECIP_DEV:
//  147 
//  148          // Sanity check
//  149          if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
??ChangeFeature_3:
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??ChangeFeature_4
//  150             return FALSE;
//  151          } else {
//  152             usbfwData.remoteWakeup = set;
        MOV     A,R6
        MOV     DPTR,#usbfwData + 18
        MOVX    @DPTR,A
//  153             usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
        JZ      ??ChangeFeature_6
        MOV     R1,#0x5
        SJMP    ??ChangeFeature_7
??ChangeFeature_6:
        MOV     R1,#0x6
??ChangeFeature_7:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
//  154          }
//  155          break;
        LJMP    ??ChangeFeature_8 & 0xFFFF
//  156 
//  157       // Endpoint
//  158       case RT_RECIP_IF:
//  159          return FALSE;
//  160 
//  161       // Endpoint
//  162       case RT_RECIP_EP:
//  163          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
??ChangeFeature_5:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     R2,A
//  164 
//  165          // Sanity check
//  166          if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        JZ      ??ChangeFeature_9
//  167             return FALSE;
??ChangeFeature_4:
        MOV     R1,#0x0
        LJMP    ??ChangeFeature_10 & 0xFFFF
//  168          } else if (endpoint > 5) {
??ChangeFeature_9:
        MOV     A,R2
        CLR     C
        SUBB    A,#0x6
        JNC     ??ChangeFeature_1
//  169             usbfwData.ep0Status = EP_STALL;
//  170          } else {
//  171             USBFW_SELECT_ENDPOINT(endpoint);
        MOV     A,R2
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
//  172 
//  173             // IN
//  174             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
        MOV     A,#usbfwData & 0xff
        ADD     A,R2
        MOV     R0,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     R1,A
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x80
        JZ      ??ChangeFeature_11
//  175                USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
        MOV     A,R6
        JZ      ??ChangeFeature_12
        MOV     A,#0x10
        SJMP    ??ChangeFeature_13
??ChangeFeature_12:
        MOV     A,#0x40
??ChangeFeature_13:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  176                usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_14
        MOV     A,#0x3
        SJMP    ??ChangeFeature_15
??ChangeFeature_14:
        CLR     A
??ChangeFeature_15:
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
//  177                usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_16
        MOV     R1,#0x8
        SJMP    ??ChangeFeature_17
??ChangeFeature_16:
        MOV     R1,#0x7
        ; Setup parameters for call to function usbsrHookProcessEvent
        SJMP    ??ChangeFeature_17
//  178 
//  179             // OUT
//  180             } else {
//  181                USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
??ChangeFeature_11:
        MOV     A,R6
        JZ      ??ChangeFeature_18
        MOV     A,#0x20
        SJMP    ??ChangeFeature_19
??ChangeFeature_18:
        MOV     A,#-0x80
??ChangeFeature_19:
        MOV     DPTR,#0x6214
        MOVX    @DPTR,A
//  182                usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_20
        MOV     A,#0x3
        SJMP    ??ChangeFeature_21
??ChangeFeature_20:
        CLR     A
??ChangeFeature_21:
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R1
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  183                usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_22
        MOV     R1,#0xa
        SJMP    ??ChangeFeature_17
??ChangeFeature_22:
        MOV     R1,#0x9
??ChangeFeature_17:
        ; Setup parameters for call to function usbsrHookProcessEvent
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
//  184             }
//  185             USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        CLR     A
        SJMP    ??ChangeFeature_23
//  186          }
//  187          break;
//  188 
//  189       default:
//  190          usbfwData.ep0Status = EP_STALL;
??ChangeFeature_1:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
??ChangeFeature_23:
        MOVX    @DPTR,A
//  191          break;
//  192       }
//  193    }
//  194    return TRUE;
??ChangeFeature_8:
        MOV     R1,#0x1
??ChangeFeature_10:
        LJMP    ??Subroutine27_0 & 0xFFFF
          CFI EndBlock cfiBlock123
//  195 } // ChangeFeature
//  196 
//  197 
//  198 
//  199 
//  200 /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
//  201  *
//  202  * The feature selector value must be appropriate to the recipient.
//  203  *
//  204  * <b>Parameters</b>:
//  205  * - VALUE: Feature selector:
//  206  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  207  *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
//  208  * - INDEX: Depends upon the recipient:
//  209  *     - DEVICE: Always 0
//  210  *     - INTERFACE: Interface number
//  211  *     - ENDPOINT: Endpoint address
//  212  * - LENGTH: Always 0
//  213  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  214 void usbsrClearFeature()
usbsrClearFeature:
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function usbsrClearFeature
        CODE
//  215 {
        FUNCALL usbsrClearFeature, ??ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrClearFeature, usbsrHookClearFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  216    if (!ChangeFeature(FALSE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x0
        LCALL   ??ChangeFeature?relay; Banked call to: ChangeFeature
        MOV     A,R1
        JNZ     ??usbsrClearFeature_0
//  217       usbsrHookClearFeature();
        ; Setup parameters for call to function usbsrHookClearFeature
        LCALL   ??usbsrHookClearFeature?relay; Banked call to: usbsrHookClearFeature
//  218    }
//  219 } // usbsrClearFeature
??usbsrClearFeature_0:
        LJMP    ??Subroutine30_0 & 0xFFFF
          CFI EndBlock cfiBlock124
//  220 
//  221 
//  222 
//  223 
//  224 /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
//  225  *
//  226  * The feature selector value must be appropriate to the recipient.
//  227  *
//  228  * <b>Parameters</b>:
//  229  * - VALUE: Feature selector:
//  230  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  231  *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
//  232  * - INDEX: Depends upon the recipient:
//  233  *     - DEVICE: Always 0
//  234  *     - INTERFACE: Interface number
//  235  *     - ENDPOINT: Endpoint address
//  236  * - LENGTH: Always 0
//  237  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  238 void usbsrSetFeature(void)
usbsrSetFeature:
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function usbsrSetFeature
        CODE
//  239 {
        FUNCALL usbsrSetFeature, ??ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetFeature, usbsrHookSetFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  240    if (!ChangeFeature(TRUE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x1
        LCALL   ??ChangeFeature?relay; Banked call to: ChangeFeature
        MOV     A,R1
        JNZ     ??usbsrSetFeature_0
//  241       usbsrHookSetFeature();
        ; Setup parameters for call to function usbsrHookSetFeature
        LCALL   ??usbsrHookSetFeature?relay; Banked call to: usbsrHookSetFeature
//  242    }
//  243 } // usbsrSetFeature
??usbsrSetFeature_0:
        LJMP    ??Subroutine30_0 & 0xFFFF
          CFI EndBlock cfiBlock125
//  244 
//  245 
//  246 
//  247 
//  248 /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
//  249  * accesses)
//  250  *
//  251  * If the value is between 1 and 127 and the device is in the default state, it will enter the address
//  252  * state. If it already is in the address state, it starts to use the newly-specified address.
//  253  *
//  254  * If the value is 0 and the device is in the address state, it will enter the default state. If it
//  255  * already is in the default state, nothing happens.
//  256  *
//  257  * <b>Parameters</b>:
//  258  * - VALUE: The device address (0-127)
//  259  * - INDEX: Always 0
//  260  * - LENGTH: Always 0
//  261  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  262 void usbsrSetAddress(void)
usbsrSetAddress:
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function usbsrSetAddress
        CODE
//  263 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  264 
//  265    // Sanity check
//  266    if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_53:
        JNZ     ??usbsrSetAddress_0
        INC     DPTR
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_54:
        JNZ     ??usbsrSetAddress_0
        MOV     DPTR,#usbSetupHeader + 2
        LCALL   ?Subroutine14 & 0xFFFF
??CrossCallReturnLabel_13:
        ANL     A,#0x80
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JZ      ??usbsrSetAddress_1
//  267       usbfwData.ep0Status = EP_STALL;
??usbsrSetAddress_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??usbsrSetAddress_2
//  268 
//  269    // Update the device address
//  270    } else {
//  271       USBADDR = LO_UINT16(usbSetupHeader.value);
??usbsrSetAddress_1:
        MOV     A,R0
        MOV     DPTR,#0x6200
        MOVX    @DPTR,A
//  272       if (LO_UINT16(usbSetupHeader.value) != 0) {
        MOV     DPTR,#usbfwData
        JZ      ??usbsrSetAddress_3
//  273          if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x3
        SJMP    ??usbsrSetAddress_2
//  274       } else {
//  275          if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
??usbsrSetAddress_3:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x2
??usbsrSetAddress_2:
        MOVX    @DPTR,A
//  276       }
//  277    }
//  278 
//  279 } // usbsrSetAddress
??usbsrSetAddress_4:
        LJMP    ??Subroutine30_0 & 0xFFFF
          CFI EndBlock cfiBlock126
//  280 
//  281 
//  282 
//  283 
//  284 /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
//  285  *
//  286  * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
//  287  * descriptors. Note that configuration descriptors also include interface, endpoint and other
//  288  * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
//  289  * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
//  290  *
//  291  * Other descriptor types that are not returned with the configuration descriptor, must be defined in
//  292  * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
//  293  * gives a pointer to the descriptor along with it's length.
//  294  *
//  295  * <b>Parameters</b>:
//  296  * - VALUE.MSB: Descriptor type
//  297  * - VALUE.LSB: Descriptor index
//  298  * - INDEX: 0, or language ID for string descriptors (currently not supported)
//  299  * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
//  300  *           whichever is the smallest)
//  301  *
//  302  * <b>Data (IN)</b>:
//  303  * The descriptor(s)
//  304  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  305 void usbsrGetDescriptor(void)
usbsrGetDescriptor:
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function usbsrGetDescriptor
        CODE
//  306 {
        FUNCALL usbsrGetDescriptor, usbdpGetDeviceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetStringDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
//  307    uint8 n;
//  308 
//  309    // Which descriptor?
//  310    switch (HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        DEC     A
        JZ      ??usbsrGetDescriptor_0
        DEC     A
        JZ      ??usbsrGetDescriptor_1
        DEC     A
        JZ      ??usbsrGetDescriptor_2
        SJMP    ??usbsrGetDescriptor_3
//  311 
//  312    // Device descriptor
//  313    case DESC_TYPE_DEVICE:
//  314       usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
??usbsrGetDescriptor_0:
        ; Setup parameters for call to function usbdpGetDeviceDesc
        LCALL   ??usbdpGetDeviceDesc?relay; Banked call to: usbdpGetDeviceDesc
        LCALL   ?Subroutine19 & 0xFFFF
//  315       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_22:
        INC     DPTR
        MOV     R3,#-0x80
        SJMP    ??usbsrGetDescriptor_4
//  316       break;
//  317 
//  318    // Configuration descriptor
//  319    case DESC_TYPE_CONFIG:
//  320       usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_1:
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R1,#0x0
        LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
        LCALL   ?Subroutine19 & 0xFFFF
//  321       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
//  322                                usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
??CrossCallReturnLabel_23:
        MOV     R3,#-0x80
        MOV     A,R1
        ADD     A,#0x2
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R4,A
        DEC     R1
        DEC     R1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOV     A,R1
        ADD     A,#0x3
        MOV     R1,A
        CLR     A
        ADDC    A,R2
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R1,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        SJMP    ??usbsrGetDescriptor_5
//  323       break;
//  324 
//  325    // String descriptor
//  326    case DESC_TYPE_STRING:
//  327       // TODO: Implement language ID
//  328       usbSetupData.pBuffer = (uint8 *)usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_2:
        ; Setup parameters for call to function usbdpGetStringDesc
        MOV     A,R2
        MOV     R1,A
        LCALL   ??usbdpGetStringDesc?relay; Banked call to: usbdpGetStringDesc
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        LCALL   ?Subroutine25 & 0xFFFF
//  329       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_32:
        INC     DPTR
        MOV     R3,#0x0
??usbsrGetDescriptor_4:
        LCALL   ?C_GPTR_LOAD
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??usbsrGetDescriptor_5:
        MOVX    @DPTR,A
//  330       break;
        LJMP    ??usbsrGetDescriptor_6 & 0xFFFF
//  331 
//  332    // Other descriptor type
//  333    default:
//  334       // Perform a table search (on index and value)
//  335       usbSetupData.pBuffer = NULL;
??usbsrGetDescriptor_3:
        MOV     DPTR,#usbSetupData
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  336       for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
        MOV     ?V3,A
        MOV     DPTR,#usbDescriptorMarker + 4
        LCALL   ??Subroutine32_0 & 0xFFFF
??CrossCallReturnLabel_43:
        LJMP    ??usbsrGetDescriptor_7 & 0xFFFF
//  337          if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
//  338              && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
//  339              && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
//  340              && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
??usbsrGetDescriptor_8:
        MOV     ?V1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,?V0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,?V1
        MOV     R1,A
        MOV     DPTR,#usbSetupHeader + 2
        LCALL   ?Subroutine17 & 0xFFFF
??CrossCallReturnLabel_18:
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R7
        MOV     R4,A
        POP     A
          CFI CFA_SP SP+0
        XRL     A,R4
        JNZ     ??usbsrGetDescriptor_9
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R6
        JNZ     ??usbsrGetDescriptor_9
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ?Subroutine17 & 0xFFFF
??CrossCallReturnLabel_19:
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R7
        MOV     R4,A
        POP     A
          CFI CFA_SP SP+0
        XRL     A,R4
        JNZ     ??usbsrGetDescriptor_9
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        XRL     A,R6
        JNZ     ??usbsrGetDescriptor_9
//  341          {
//  342             usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     ?V0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     ?V1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  343             usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  344          }
//  345       }
??usbsrGetDescriptor_9:
        INC     ?V3
??usbsrGetDescriptor_7:
        MOV     ?V0,?V3
        MOV     DPTR,#usbDescriptorMarker + 6
        LCALL   ?Subroutine14 & 0xFFFF
//  346    }
??CrossCallReturnLabel_14:
        CLR     C
        SUBB    A,R2
        MOV     ?V4,A
        MOV     A,R1
        SUBB    A,R3
        MOV     ?V5,A
        MOV     A,#0x3
        MOV     R0,#?V4
        LCALL   ?US_SHR
        CLR     C
        MOV     A,?V0
        SUBB    A,?V4
        CLR     A
        SUBB    A,?V5
        JNC     $+5
        LJMP    ??usbsrGetDescriptor_8 & 0xFFFF
//  347 
//  348    // Stall EP0 if no descriptor was found
//  349    if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
??usbsrGetDescriptor_6:
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,R4
        ORL     A,R5
        ORL     A,R6
        MOV     DPTR,#usbfwData + 7
        JNZ     ??usbsrGetDescriptor_10
        MOV     A,#0x4
        SJMP    ??usbsrGetDescriptor_11
//  350 
//  351    if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetDescriptor_10:
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetDescriptor_12
//  352 
//  353       // Limit the returned descriptor size (the PC wants to know about sizes before
//  354       // polling the complete descriptors)
//  355       if (usbSetupData.bytesLeft > usbSetupHeader.length) {
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine32_0 & 0xFFFF
??CrossCallReturnLabel_44:
        LCALL   ?Subroutine15 & 0xFFFF
??CrossCallReturnLabel_40:
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        JNC     ??usbsrGetDescriptor_13
//  356          usbSetupData.bytesLeft = usbSetupHeader.length;
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  357       }
//  358 
//  359       usbfwData.ep0Status = EP_TX;
??usbsrGetDescriptor_13:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x1
??usbsrGetDescriptor_11:
        MOVX    @DPTR,A
//  360    }
//  361 
//  362 } // usbsrGetDescriptor
??usbsrGetDescriptor_12:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock127

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine19:
          CFI Block cfiCond128 Using cfiCommon0
          CFI Function usbsrGetDescriptor
          CFI Conditional ??CrossCallReturnLabel_22
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond129 Using cfiCommon0
          CFI (cfiCond129) Function usbsrGetDescriptor
          CFI (cfiCond129) Conditional ??CrossCallReturnLabel_23
          CFI (cfiCond129) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond129) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond129) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond129) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond129) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond129) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond129) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond129) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond129) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond129) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond129) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond129) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond129) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond129) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond129) CFA_SP SP+-2
          CFI (cfiCond129) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker130 Using cfiCommon1
          CFI (cfiPicker130) NoFunction
          CFI (cfiPicker130) Picker
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        LCALL   ?Subroutine25 & 0xFFFF
??CrossCallReturnLabel_33:
        RET
          CFI EndBlock cfiCond128
          CFI EndBlock cfiCond129
          CFI EndBlock cfiPicker130

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine25:
          CFI Block cfiCond131 Using cfiCommon0
          CFI Function usbsrGetDescriptor
          CFI Conditional ??CrossCallReturnLabel_32
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond132 Using cfiCommon0
          CFI (cfiCond132) Function usbsrGetDescriptor
          CFI (cfiCond132) Conditional ??CrossCallReturnLabel_33, ??CrossCallReturnLabel_22
          CFI (cfiCond132) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond132) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond132) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond132) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond132) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond132) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond132) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond132) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond132) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond132) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond132) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond132) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond132) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond132) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond132) CFA_SP SP+-4
          CFI (cfiCond132) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond133 Using cfiCommon0
          CFI (cfiCond133) Function usbsrGetDescriptor
          CFI (cfiCond133) Conditional ??CrossCallReturnLabel_33, ??CrossCallReturnLabel_23
          CFI (cfiCond133) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond133) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond133) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond133) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond133) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond133) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond133) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond133) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond133) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond133) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond133) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond133) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond133) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond133) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond133) CFA_SP SP+-4
          CFI (cfiCond133) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker134 Using cfiCommon1
          CFI (cfiPicker134) NoFunction
          CFI (cfiPicker134) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        RET
          CFI EndBlock cfiCond131
          CFI EndBlock cfiCond132
          CFI EndBlock cfiCond133
          CFI EndBlock cfiPicker134

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine17:
          CFI Block cfiCond135 Using cfiCommon0
          CFI Function usbsrGetDescriptor
          CFI Conditional ??CrossCallReturnLabel_18
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond136 Using cfiCommon0
          CFI (cfiCond136) Function usbsrGetDescriptor
          CFI (cfiCond136) Conditional ??CrossCallReturnLabel_19
          CFI (cfiCond136) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond136) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond136) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond136) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond136) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond136) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond136) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond136) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond136) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond136) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond136) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond136) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond136) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond136) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond136) CFA_SP SP+-2
          CFI (cfiCond136) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker137 Using cfiCommon1
          CFI (cfiPicker137) NoFunction
          CFI (cfiPicker137) Picker
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
          CFI EndBlock cfiCond135
          CFI EndBlock cfiCond136
          CFI EndBlock cfiPicker137

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine14:
          CFI Block cfiCond138 Using cfiCommon0
          CFI Function usbsrSetAddress
          CFI Conditional ??CrossCallReturnLabel_13
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond139 Using cfiCommon0
          CFI (cfiCond139) Function usbsrGetDescriptor
          CFI (cfiCond139) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond139) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond139) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond139) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond139) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond139) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond139) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond139) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond139) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond139) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond139) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond139) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond139) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond139) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond139) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond139) CFA_SP SP+-2
          CFI (cfiCond139) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiCond140 Using cfiCommon0
          CFI (cfiCond140) Function ??ConfigureEndpoints
          CFI (cfiCond140) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond140) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond140) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond140) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond140) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond140) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond140) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond140) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond140) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond140) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond140) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond140) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond140) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond140) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond140) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond140) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond140) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond140) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond140) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond140) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond140) CFA_SP SP+-2
          CFI (cfiCond140) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiPicker141 Using cfiCommon1
          CFI (cfiPicker141) NoFunction
          CFI (cfiPicker141) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_64:
        MOV     A,R0
        RET
          CFI EndBlock cfiCond138
          CFI EndBlock cfiCond139
          CFI EndBlock cfiCond140
          CFI EndBlock cfiPicker141
//  363 
//  364 
//  365 
//  366 /** \brief Internally used function that configures all endpoints for the specified interface
//  367  *
//  368  * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
//  369  * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
//  370  * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
//  371  * interface descriptor to define endpoint double-buffering.
//  372  *
//  373  * \param[in]       *pInterface
//  374  *     A pointer to the interface descriptor
//  375  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  376 static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
??ConfigureEndpoints:
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function ??ConfigureEndpoints
        CODE
//  377 {
        FUNCALL ??ConfigureEndpoints, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 19, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 19, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        REQUIRE ?V4
        REQUIRE ?V5
        REQUIRE ?V6
        REQUIRE ?V7
        REQUIRE ?V8
        REQUIRE ?V9
        REQUIRE ?V10
        MOV     A,#-0x13
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 19)
        ; Saved register size: 19
        ; Auto size: 0
//  378    uint8 n;
//  379    uint16 maxpRegValue;
//  380    uint8 csRegValue;
//  381    uint8 endpoint;
//  382    USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
//  383    DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
//  384 
//  385    // Locate the double buffer settings
//  386    if (pInterface->bNumEndpoints) {
        MOV     A,R2
        ADD     A,#0x4
        MOV     ?V0,A
        CLR     A
        ADDC    A,R3
        MOV     ?V1,A
        MOV     DPL,?V0
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        JZ      ??ConfigureEndpoints_1
//  387        pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
        MOV     DPTR,#usbDescriptorMarker + 8
        LCALL   ?Subroutine14 & 0xFFFF
??CrossCallReturnLabel_15:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        SJMP    ??ConfigureEndpoints_2
//  388        while (pUsbDblbufLutInfo->pInterface != pInterface) {
//  389           pUsbDblbufLutInfo++;
??ConfigureEndpoints_3:
        MOV     A,R6
        ADD     A,#0x4
        MOV     R6,A
        JNC     ??ConfigureEndpoints_2
        INC     R7
//  390        }
??ConfigureEndpoints_2:
        MOV     DPL,R6
        MOV     DPH,R7
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,R2
        XRL     A,R0
        JNZ     ??ConfigureEndpoints_4
        MOV     A,R3
        XRL     A,R1
??ConfigureEndpoints_4:
        JNZ     ??ConfigureEndpoints_3
//  391    }
//  392 
//  393    // For each endpoint in this interface
//  394    for (n = 0; n < pInterface->bNumEndpoints; n++) {
??ConfigureEndpoints_1:
        MOV     ?V4,#0x0
        SJMP    ??ConfigureEndpoints_5
//  395       if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
//  396 
//  397          // Get the endpoint index
//  398          endpoint = pEndpoint->bEndpointAddress & 0x0F;
//  399          USBFW_SELECT_ENDPOINT(endpoint);
//  400 
//  401          csRegValue = 0x00;
//  402          maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
//  403 
//  404          // For IN endpoints...
//  405          if (pEndpoint->bEndpointAddress & 0x80) {
//  406 
//  407             // Clear data toggle, and flush twice (due to double buffering)
//  408             USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
//  409             USBCSIL = USBCSIL_FLUSH_PACKET;
//  410 
//  411             // USBCSIH
//  412             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
//  413             if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
//  414             USBCSIH = csRegValue;
//  415 
//  416             // Max transfer size
//  417             USBMAXI = maxpRegValue;
//  418 
//  419             // Endpoint status
//  420             usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
//  421 
//  422          // For OUT endpoints...
//  423          } else {
//  424 
//  425             // Clear data toggle, and flush twice (due to double buffering)
//  426             USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
??ConfigureEndpoints_6:
        MOV     DPTR,#0x6214
        MOV     A,#-0x70
        MOVX    @DPTR,A
//  427             USBCSOL = USBCSOL_FLUSH_PACKET;
        MOV     A,#0x10
        LCALL   ?Subroutine21 & 0xFFFF
//  428 
//  429             // USBCSOH
//  430             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
??CrossCallReturnLabel_26:
        JNZ     ??ConfigureEndpoints_7
        MOV     ?V5,#0x40
//  431             if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
??ConfigureEndpoints_7:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,?V8
        JZ      ??ConfigureEndpoints_8
        MOV     A,?V5
        SETB    0xE0 /* A   */.0
        MOV     ?V5,A
//  432             USBCSOH = csRegValue;
??ConfigureEndpoints_8:
        MOV     A,?V5
        MOV     DPTR,#0x6215
        MOVX    @DPTR,A
//  433 
//  434             // Max transfer size
//  435             USBMAXO = maxpRegValue;
        MOV     A,R2
        MOV     DPTR,#0x6213
        MOVX    @DPTR,A
//  436 
//  437             // Endpoint status
//  438             usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
        MOV     A,R4
        ADD     A,#0xc
        MOV     DPL,A
        CLR     A
        ADDC    A,R5
        MOV     DPH,A
??ConfigureEndpoints_9:
        CLR     A
        MOVX    @DPTR,A
//  439          }
//  440          USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
??ConfigureEndpoints_10:
        INC     ?V4
??ConfigureEndpoints_5:
        MOV     DPL,?V0
        MOV     DPH,?V1
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,?V4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??ConfigureEndpoints_11 & 0xFFFF
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x5
        LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
        MOV     ?V6,R2
        MOV     ?V7,R3
        MOV     A,R2
        ORL     A,?V7
        JZ      ??ConfigureEndpoints_10
        MOV     A,R2
        ADD     A,#0x2
        MOV     R0,A
        CLR     A
        ADDC    A,?V7
        MOV     R1,A
        MOV     ?V2,R0
        MOV     ?V3,R1
        MOV     DPL,R0
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0xf
        MOV     ?V10,A
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
        MOV     ?V5,#0x0
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADD     A,#0x7
        MOV     ?V8,A
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADDC    A,#0x0
        MOV     ?V9,A
        MOV     A,#0x3
        MOV     R0,#?V8
        LCALL   ?US_SHR
        MOV     R2,?V8
        MOV     ?V8,?V10
        MOV     A,#usbfwData & 0xff
        ADD     A,?V8
        MOV     R0,A
        CLR     A
        ADDC    A,#(usbfwData >> 8) & 0xff
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     ?V8,#0x1
        MOV     ?V9,#0x0
        MOV     A,?V10
        MOV     R0,#?V8
        LCALL   ?S_SHL
        MOV     A,?V6
        ADD     A,#0x3
        MOV     R0,A
        CLR     A
        ADDC    A,?V7
        MOV     R1,A
        MOV     DPL,?V2
        MOV     DPH,?V3
        CLR     A
        MOVC    A,@A+DPTR
        MOV     C,0xE0 /* A   */.7
        JC      $+5
        LJMP    ??ConfigureEndpoints_6 & 0xFFFF
        MOV     DPTR,#0x6211
        MOV     A,#0x48
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?Subroutine21 & 0xFFFF
??CrossCallReturnLabel_27:
        JNZ     ??ConfigureEndpoints_12
        MOV     ?V5,#0x40
??ConfigureEndpoints_12:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,?V8
        JZ      ??ConfigureEndpoints_13
        MOV     A,?V5
        SETB    0xE0 /* A   */.0
        MOV     ?V5,A
??ConfigureEndpoints_13:
        MOV     A,?V5
        MOV     DPTR,#0x6212
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     DPTR,#0x6210
        MOVX    @DPTR,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LJMP    ??ConfigureEndpoints_9 & 0xFFFF
//  441       }
//  442    }
//  443 } // ConfigureEndpoints
??ConfigureEndpoints_11:
        MOV     R7,#0xb
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock142

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine21:
          CFI Block cfiCond143 Using cfiCommon0
          CFI Function ??ConfigureEndpoints
          CFI Conditional ??CrossCallReturnLabel_26
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 19)
          CFI Block cfiCond144 Using cfiCommon0
          CFI (cfiCond144) Function ??ConfigureEndpoints
          CFI (cfiCond144) Conditional ??CrossCallReturnLabel_27
          CFI (cfiCond144) R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI (cfiCond144) VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI (cfiCond144) V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI (cfiCond144) V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI (cfiCond144) V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI (cfiCond144) V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI (cfiCond144) V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI (cfiCond144) V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond144) V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond144) V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond144) V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond144) V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond144) V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond144) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond144) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond144) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond144) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond144) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond144) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond144) CFA_SP SP+-2
          CFI (cfiCond144) CFA_XSP16 add(XSP16, 19)
          CFI Block cfiPicker145 Using cfiCommon1
          CFI (cfiPicker145) NoFunction
          CFI (cfiPicker145) Picker
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0x3
        XRL     A,#0x1
        RET
          CFI EndBlock cfiCond143
          CFI EndBlock cfiCond144
          CFI EndBlock cfiPicker145
//  444 
//  445 
//  446 
//  447 
//  448 /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
//  449  *
//  450  * If the returned value is 0, the device is not configured (not in the configured state)
//  451  *
//  452  * <b>Parameters</b>:
//  453  * - VALUE: Always 0
//  454  * - INDEX: Always 0
//  455  * - LENGTH: Always 1
//  456  *
//  457  * <b>Data (IN)</b>:
//  458  * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
//  459  * configuration.
//  460  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  461 void usbsrGetConfiguration(void)
usbsrGetConfiguration:
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function usbsrGetConfiguration
        CODE
//  462 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  463 
//  464    // Sanity check
//  465    if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_60:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_55:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetConfiguration_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetConfiguration_1:
        JZ      ??usbsrGetConfiguration_2
//  466       usbfwData.ep0Status = EP_STALL;
??usbsrGetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_24
//  467 
//  468    // Return the current configuration
//  469    } else {
//  470       usbSetupData.pBuffer = &usbfwData.configurationValue;
??usbsrGetConfiguration_2:
        MOV     DPTR,#usbSetupData
        MOV     A,#(usbfwData + 1) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((usbfwData + 1) >> 8) & 0xff
        LCALL   ?Subroutine20 & 0xFFFF
//  471       usbSetupData.bytesLeft = 1;
//  472       usbfwData.ep0Status = EP_TX;
//  473    }
??CrossCallReturnLabel_24:
        LJMP    ??Subroutine29_0 & 0xFFFF
          CFI EndBlock cfiBlock146
//  474 
//  475 } // usbsrGetConfiguration

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
          CFI Block cfiCond147 Using cfiCommon0
          CFI Function usbsrGetStatus
          CFI Conditional ??CrossCallReturnLabel_59
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond148 Using cfiCommon0
          CFI (cfiCond148) Function usbsrGetConfiguration
          CFI (cfiCond148) Conditional ??CrossCallReturnLabel_60
          CFI (cfiCond148) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond148) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond148) CFA_SP SP+-7
          CFI Block cfiCond149 Using cfiCommon0
          CFI (cfiCond149) Function usbsrGetInterface
          CFI (cfiCond149) Conditional ??CrossCallReturnLabel_61
          CFI (cfiCond149) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond149) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond149) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond149) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond149) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond149) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond149) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond149) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond149) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond149) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond149) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond149) CFA_SP SP+-2
          CFI (cfiCond149) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker150 Using cfiCommon1
          CFI (cfiPicker150) NoFunction
          CFI (cfiPicker150) Picker
        MOV     DPTR,#usbSetupHeader + 2
          CFI EndBlock cfiCond147
          CFI EndBlock cfiCond148
          CFI EndBlock cfiCond149
          CFI EndBlock cfiPicker150
        REQUIRE ??Subroutine33_0
        ; // Fall through to label ??Subroutine33_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine33_0:
          CFI Block cfiCond151 Using cfiCommon0
          CFI Function ublExec
          CFI Conditional ??CrossCallReturnLabel_49
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 16)
          CFI Block cfiCond152 Using cfiCommon0
          CFI (cfiCond152) Function usbfwSetupHandler
          CFI (cfiCond152) Conditional ??CrossCallReturnLabel_50
          CFI (cfiCond152) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond152) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond152) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond152) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond152) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond152) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond152) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond152) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond152) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond152) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond152) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond152) CFA_SP SP+-2
          CFI (cfiCond152) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond153 Using cfiCommon0
          CFI (cfiCond153) Function ??ChangeFeature
          CFI (cfiCond153) Conditional ??CrossCallReturnLabel_51
          CFI (cfiCond153) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond153) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond153) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond153) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond153) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond153) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond153) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond153) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond153) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond153) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond153) CFA_SP SP+-2
          CFI (cfiCond153) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond154 Using cfiCommon0
          CFI (cfiCond154) Function ??ChangeFeature
          CFI (cfiCond154) Conditional ??CrossCallReturnLabel_52
          CFI (cfiCond154) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond154) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond154) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond154) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond154) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond154) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond154) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond154) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond154) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond154) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond154) CFA_SP SP+-2
          CFI (cfiCond154) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond155 Using cfiCommon0
          CFI (cfiCond155) Function usbsrSetAddress
          CFI (cfiCond155) Conditional ??CrossCallReturnLabel_53
          CFI (cfiCond155) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond155) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond155) CFA_SP SP+-7
          CFI Block cfiCond156 Using cfiCommon0
          CFI (cfiCond156) Function usbsrSetAddress
          CFI (cfiCond156) Conditional ??CrossCallReturnLabel_54
          CFI (cfiCond156) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond156) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond156) CFA_SP SP+-7
          CFI Block cfiCond157 Using cfiCommon0
          CFI (cfiCond157) Function usbsrGetConfiguration
          CFI (cfiCond157) Conditional ??CrossCallReturnLabel_55
          CFI (cfiCond157) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond157) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond157) CFA_SP SP+-7
          CFI Block cfiCond158 Using cfiCommon0
          CFI (cfiCond158) Function usbsrSetConfiguration
          CFI (cfiCond158) Conditional ??CrossCallReturnLabel_56
          CFI (cfiCond158) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond158) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond158) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond158) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond158) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond158) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond158) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond158) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond158) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond158) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond158) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond158) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond158) CFA_SP SP+-2
          CFI (cfiCond158) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond159 Using cfiCommon0
          CFI (cfiCond159) Function usbsrSetConfiguration
          CFI (cfiCond159) Conditional ??CrossCallReturnLabel_57
          CFI (cfiCond159) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond159) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond159) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond159) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond159) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond159) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond159) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond159) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond159) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond159) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond159) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond159) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond159) CFA_SP SP+-2
          CFI (cfiCond159) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond160 Using cfiCommon0
          CFI (cfiCond160) Function usbsrSetInterface
          CFI (cfiCond160) Conditional ??CrossCallReturnLabel_58
          CFI (cfiCond160) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond160) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond160) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond160) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond160) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond160) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond160) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond160) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond160) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond160) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond160) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond160) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond160) CFA_SP SP+-2
          CFI (cfiCond160) CFA_XSP16 add(XSP16, 12)
          CFI Block cfiCond161 Using cfiCommon0
          CFI (cfiCond161) Function usbsrGetStatus
          CFI (cfiCond161) Conditional ??CrossCallReturnLabel_59
          CFI (cfiCond161) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond161) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond161) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond161) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond161) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond161) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond161) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond161) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond161) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond161) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond161) CFA_SP SP+-2
          CFI (cfiCond161) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond162 Using cfiCommon0
          CFI (cfiCond162) Function usbsrGetConfiguration
          CFI (cfiCond162) Conditional ??CrossCallReturnLabel_60
          CFI (cfiCond162) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond162) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond162) CFA_SP SP+-7
          CFI Block cfiCond163 Using cfiCommon0
          CFI (cfiCond163) Function usbsrGetInterface
          CFI (cfiCond163) Conditional ??CrossCallReturnLabel_61
          CFI (cfiCond163) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond163) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond163) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond163) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond163) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond163) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond163) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond163) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond163) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond163) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond163) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond163) CFA_SP SP+-2
          CFI (cfiCond163) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker164 Using cfiCommon1
          CFI (cfiPicker164) NoFunction
          CFI (cfiPicker164) Picker
        LCALL   ?Subroutine23 & 0xFFFF
??CrossCallReturnLabel_66:
        MOV     A,R0
        ORL     A,R1
        RET
          CFI EndBlock cfiCond151
          CFI EndBlock cfiCond152
          CFI EndBlock cfiCond153
          CFI EndBlock cfiCond154
          CFI EndBlock cfiCond155
          CFI EndBlock cfiCond156
          CFI EndBlock cfiCond157
          CFI EndBlock cfiCond158
          CFI EndBlock cfiCond159
          CFI EndBlock cfiCond160
          CFI EndBlock cfiCond161
          CFI EndBlock cfiCond162
          CFI EndBlock cfiCond163
          CFI EndBlock cfiPicker164
//  476 
//  477 
//  478 
//  479 
//  480 /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
//  481  *
//  482  * The configuration value must either be 0, in which case the device enters the address state, or it
//  483  * must match a configuration value from one of the USB configuration descriptors. If there is a match,
//  484  * the device enters the configured state.
//  485  *
//  486  * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
//  487  * function to automatically setup all endpoint registers.
//  488  *
//  489  * <b>Parameters</b>:
//  490  * - VALUE: The configuration value (0-255)
//  491  * - INDEX: Always 0
//  492  * - LENGTH: Always 0
//  493  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  494 void usbsrSetConfiguration(void)
usbsrSetConfiguration:
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function usbsrSetConfiguration
        CODE
//  495 {
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, ??ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbfwSetAllEpStatus
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  496    uint8 n;
//  497    USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
//  498    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  499 
//  500    // Sanity check
//  501    if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_56:
        JNZ     ??usbsrSetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_57:
        JNZ     ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 3
        MOVX    A,@DPTR
        JZ      ??usbsrSetConfiguration_1
//  502       usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetConfiguration_2
//  503 
//  504    // Default endpoint setup
//  505    } else {
//  506       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
??usbsrSetConfiguration_1:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
//  507 
//  508       // Configure relevant endpoints
//  509       if (LO_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R6,A
        JZ      ??usbsrSetConfiguration_3
//  510 
//  511          // Find the correct configuration descriptor...
//  512          pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        MOV     R1,A
        LCALL   ??usbdpGetConfigurationDesc?relay; Banked call to: usbdpGetConfigurationDesc
        MOV     ?V0,R2
        MOV     ?V1,R3
//  513 
//  514          // If it exists...
//  515          if (pConfiguration) {
        MOV     A,R2
        ORL     A,?V1
        JZ      ??usbsrSetConfiguration_4
//  516             usbfwData.usbState = DEV_CONFIGURED;
        MOV     DPTR,#usbfwData
        MOV     A,#0x4
        MOVX    @DPTR,A
//  517             usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
        MOV     A,R6
        INC     DPTR
        MOVX    @DPTR,A
//  518 
//  519             // For each interface...
//  520             for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
        MOV     R6,#0x0
??usbsrSetConfiguration_5:
        MOV     DPL,?V0
        MOV     DPH,?V1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JNC     ??usbsrSetConfiguration_6
//  521                usbfwData.pAlternateSetting[n] = 0x00;
        MOV     A,#(usbfwData + 2) & 0xff
        ADD     A,R6
        MOV     DPL,A
        CLR     A
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     DPH,A
        CLR     A
        MOVX    @DPTR,A
//  522 
//  523                // Look only for alternate setting 0
//  524                do {
//  525                   pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
??usbsrSetConfiguration_7:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x4
        LCALL   ??usbdpFindNext?relay; Banked call to: usbdpFindNext
//  526                } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        JNZ     ??usbsrSetConfiguration_7
//  527 
//  528                // Configure all endpoints in this interface
//  529                ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        LCALL   ??ConfigureEndpoints?relay; Banked call to: ConfigureEndpoints
//  530             }
        INC     R6
        SJMP    ??usbsrSetConfiguration_5
//  531 
//  532          // If not, then stall the endpoint
//  533          } else {
//  534             usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_4:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetConfiguration_6
//  535          }
//  536 
//  537       // Unconfigure endpoints
//  538       } else {
//  539          usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
??usbsrSetConfiguration_3:
        MOV     DPTR,#usbfwData + 1
        MOVX    @DPTR,A
//  540          usbfwData.usbState = DEV_ADDRESS;
        MOV     DPTR,#usbfwData
        MOV     A,#0x3
        MOVX    @DPTR,A
//  541          usbfwSetAllEpStatus(EP_HALT);
        ; Setup parameters for call to function usbfwSetAllEpStatus
        MOV     R1,A
        LCALL   ??usbfwSetAllEpStatus?relay; Banked call to: usbfwSetAllEpStatus
//  542       }
//  543       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
??usbsrSetConfiguration_6:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
//  544    }
//  545 
//  546 } // usbsrSetConfiguration
??usbsrSetConfiguration_2:
        LJMP    ?Subroutine0 & 0xFFFF
          CFI EndBlock cfiBlock165
//  547 
//  548 
//  549 
//  550 
//  551 /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
//  552  * specified interface)
//  553  *
//  554  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  555  * the host to determine the currently selected alternate setting.
//  556  *
//  557  * <b>Parameters</b>:
//  558  * - VALUE: Always 0
//  559  * - INDEX: Interface number
//  560  * - LENGTH: Always 1
//  561  *
//  562  * <b>Data (IN)</b>:
//  563  * The alternate setting for the selected interface
//  564  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  565 void usbsrGetInterface(void)
usbsrGetInterface:
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function usbsrGetInterface
        CODE
//  566 {
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  567 
//  568    // Sanity check
//  569    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x81
        JNZ     ??usbsrGetInterface_0
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_61:
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetInterface_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetInterface_1:
        JZ      ??usbsrGetInterface_2
//  570       usbfwData.ep0Status = EP_STALL;
??usbsrGetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_25
//  571 
//  572    // Return the current alternate setting
//  573    } else {
//  574       usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
??usbsrGetInterface_2:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     ?V1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V1
        LCALL   ?Subroutine20 & 0xFFFF
//  575       usbSetupData.bytesLeft = 1;
//  576       usbfwData.ep0Status = EP_TX;
//  577    }
??CrossCallReturnLabel_25:
        LJMP    ?Subroutine3 & 0xFFFF
          CFI EndBlock cfiBlock166
//  578 
//  579 } // usbsrGetInterface

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine20:
          CFI Block cfiCond167 Using cfiCommon0
          CFI Function usbsrGetConfiguration
          CFI Conditional ??CrossCallReturnLabel_24
          CFI DPL0 Frame(CFA_SP, 4)
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-7
          CFI Block cfiCond168 Using cfiCommon0
          CFI (cfiCond168) Function usbsrGetInterface
          CFI (cfiCond168) Conditional ??CrossCallReturnLabel_25
          CFI (cfiCond168) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond168) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond168) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond168) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond168) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond168) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond168) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond168) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond168) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond168) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond168) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond168) CFA_SP SP+-2
          CFI (cfiCond168) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker169 Using cfiCommon1
          CFI (cfiPicker169) NoFunction
          CFI (cfiPicker169) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        INC     A
        LCALL   ?Subroutine26 & 0xFFFF
??CrossCallReturnLabel_35:
        RET
          CFI EndBlock cfiCond167
          CFI EndBlock cfiCond168
          CFI EndBlock cfiPicker169

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine26:
          CFI Block cfiCond170 Using cfiCommon0
          CFI Function usbsrGetStatus
          CFI Conditional ??CrossCallReturnLabel_34
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond171 Using cfiCommon0
          CFI (cfiCond171) Function usbsrGetConfiguration
          CFI (cfiCond171) Conditional ??CrossCallReturnLabel_35, ??CrossCallReturnLabel_24
          CFI (cfiCond171) DPL0 Frame(CFA_SP, 4)
          CFI (cfiCond171) DPH0 Frame(CFA_SP, 5)
          CFI (cfiCond171) CFA_SP SP+-9
          CFI Block cfiCond172 Using cfiCommon0
          CFI (cfiCond172) Function usbsrGetInterface
          CFI (cfiCond172) Conditional ??CrossCallReturnLabel_35, ??CrossCallReturnLabel_25
          CFI (cfiCond172) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond172) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond172) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond172) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond172) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond172) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond172) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond172) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond172) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond172) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond172) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond172) CFA_SP SP+-4
          CFI (cfiCond172) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker173 Using cfiCommon1
          CFI (cfiPicker173) NoFunction
          CFI (cfiPicker173) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#usbfwData + 7
        INC     A
        RET
          CFI EndBlock cfiCond170
          CFI EndBlock cfiCond171
          CFI EndBlock cfiCond172
          CFI EndBlock cfiPicker173
//  580 
//  581 
//  582 
//  583 
//  584 /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
//  585  * interface)
//  586  *
//  587  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  588  * the host to select the desired alternate setting.
//  589  *
//  590  * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
//  591  * registers.
//  592  *
//  593  * <b>Parameters</b>:
//  594  * - VALUE: Alternate setting
//  595  * - INDEX: Interface number
//  596  * - LENGTH: Always 0
//  597  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  598 void usbsrSetInterface(void)
usbsrSetInterface:
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function usbsrSetInterface
        CODE
//  599 {
        FUNCALL usbsrSetInterface, usbdpGetInterfaceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, ??ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  600    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  601 
//  602    // Sanity check
//  603    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine33_0 & 0xFFFF
??CrossCallReturnLabel_58:
        JNZ     ??usbsrSetInterface_0
//  604       usbfwData.ep0Status = EP_STALL;
//  605 
//  606    // Verify that the desired alternate setting is available, and then make the switch
//  607    } else {
//  608       if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R6,A
        ; Setup parameters for call to function usbdpGetInterfaceDesc
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R2,A
        MOV     DPTR,#usbfwData + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??usbdpGetInterfaceDesc?relay; Banked call to: usbdpGetInterfaceDesc
        MOV     ?V0,R2
        MOV     ?V1,R3
        MOV     A,R2
        ORL     A,?V1
        JZ      ??usbsrSetInterface_0
//  609          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     A,R6
        MOV     R2,A
        MOV     R1,#0x3
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
//  610          usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  611 
//  612          // Configure all endpoints in this interface
//  613          ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        MOV     R2,?V0
        MOV     R3,?V1
        LCALL   ??ConfigureEndpoints?relay; Banked call to: ConfigureEndpoints
//  614          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x4
        LCALL   ??usbsrHookProcessEvent?relay; Banked call to: usbsrHookProcessEvent
        SJMP    ??usbsrSetInterface_1
//  615 
//  616       // This interface does not exist
//  617       } else {
//  618          usbfwData.ep0Status = EP_STALL;
??usbsrSetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
//  619       }
//  620    }
//  621 
//  622 } // usbsrSetInterface
??usbsrSetInterface_1:
        LJMP    ?Subroutine0 & 0xFFFF
          CFI EndBlock cfiBlock174
//  623 
//  624 //@}
//  625 
//  626 /*
//  627 +------------------------------------------------------------------------------
//  628 |  Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
//  629 |
//  630 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  631 |  granted under the terms of a software license agreement between the user who
//  632 |  downloaded the software, his/her employer (which must be your employer) and
//  633 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  634 |  unless you agree to abide by the terms of the License. The License limits
//  635 |  your use, and you acknowledge, that the Software may not be modified, copied
//  636 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  637 |  solely and exclusively in conjunction with a Texas Instruments radio
//  638 |  frequency transceiver, which is integrated into your product. Other than for
//  639 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  640 |  works of, modify, distribute, perform, display or sell this Software and/or
//  641 |  its documentation for any purpose.
//  642 |
//  643 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  644 |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  645 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  646 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  647 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  648 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  649 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  650 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  651 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  652 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  653 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  654 |
//  655 |  Should you have any questions regarding your right to use this Software,
//  656 |  contact Texas Instruments Incorporated at www.TI.com.
//  657 |
//  658 +------------------------------------------------------------------------------
//  659 */
// C:\Texas Instruments\BLE-CC254x-1.4.0\Projects\ble\util\UBL\soc_8051\usb_msd\hal\usb\usb_suspend.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_suspend.c
//    4 
//    5     Description:  USB library common functionality.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_suspend
//   10 /// @{
//   11 #include "usb_firmware_library_headers.h"
//   12 #include "hal_board.h"
//   13 #include "hal_mcu.h"
//   14 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   15 __xdata VFPTR pFnSuspendEnterHook=  NULL;
pFnSuspendEnterHook:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   16 __xdata VFPTR pFnSuspendExitHook=   NULL;
pFnSuspendExitHook:
        DS 2
        REQUIRE __INIT_XDATA_Z
//   17 
//   18 #if HAL_UART_USB_SUSPEND
//   19 extern void halEnterPowerMode(void);
//   20 
//   21 /** \brief Puts the chip into power mode 1 during USB suspend.
//   22  *
//   23  * This function must be called from main (i.e. not from interrupt context) upon the reception of a
//   24  * \ref USBIRQ_EVENT_SUSPEND event. To comply with the USB specification, this must happen within 10 ms
//   25  * after the event occurs. The chip will stay in power mode 1 until a USB resume or USB reset is detected
//   26  * on the USB bus, or remote wakeup is used. During this period, the MCU can only run code from
//   27  * interrupt context.
//   28  */
//   29 void usbsuspEnter(void)
//   30 {
//   31     if (pFnSuspendEnterHook!=NULL)
//   32         pFnSuspendEnterHook();
//   33 
//   34     HAL_USB_INT_CLEAR();
//   35     HAL_USB_INT_ENABLE();
//   36 
//   37     // Disable USB clock (PLL) before entering PM1
//   38     HAL_USB_PLL_DISABLE();
//   39 
//   40     HAL_LED_CLR_1();
//   41 
//   42     do {
//   43         // Enter PM1, in prescribed manner as explained in CC253x User's Guide
//   44         SLEEPCMD = 0x05;
//   45         halEnterPowerMode();
//   46     } while ( usbirqData.inSuspend );
//   47 
//   48     // .... we are now up and running again
//   49 
//   50     // First make sure that the crystal oscillator is stable
//   51     while (!CC2530_IS_XOSC_STABLE());
//   52 
//   53     // Restart the USB clock (PLL)
//   54     HAL_USB_ENABLE();
//   55 
//   56     if (pFnSuspendExitHook!=NULL)
//   57         pFnSuspendExitHook();
//   58 } // usbsuspEnter
//   59 #endif
//   60 
//   61 
//   62 
//   63 /** \brief Attempts USB remote wakeup.
//   64  *
//   65  * This function can be called from interrupt context while the USB device is suspend mode. If the device
//   66  * is privileged to do so (see \c usbfwData.remoteWakeup and the \ref USBSR_EVENT_REMOTE_WAKEUP_ENABLED
//   67  * and \ref USBSR_EVENT_REMOTE_WAKEUP_DISABLED events), remote wakeup will be performed. Note that this
//   68  * function will block for 10 ms while the resume signal is set on the bus. Note: This function can only
//   69  * be called when the 48 MHz XOSC is stable.
//   70  *
//   71  * \return
//   72  *     \c TRUE if the remote wakeup was performed (the privilege had been granted), otherwise \c FALSE
//   73  *     (the device is still in suspend mode).
//   74  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   75 uint8 usbsuspDoRemoteWakeup(void)
usbsuspDoRemoteWakeup:
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function usbsuspDoRemoteWakeup
        CODE
//   76 {
        FUNCALL usbsuspDoRemoteWakeup, halMcuWaitMs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//   77    extern void halMcuWaitMs(uint16 msec);
//   78    halIntState_t   intState;
//   79 
//   80    // Make sure that it's OK
//   81    if (!usbfwData.remoteWakeup) return FALSE;
        MOV     DPTR,#usbfwData + 18
        MOVX    A,@DPTR
        JNZ     ??usbsuspDoRemoteWakeup_0
        MOV     R1,#0x0
        SJMP    ??usbsuspDoRemoteWakeup_1
//   82 
//   83    HAL_ENTER_CRITICAL_SECTION(intState);
??usbsuspDoRemoteWakeup_0:
        MOV     A,0xa8
        MOV     R6,A
        CLR     0xa8.7
//   84 
//   85    // Make sure that the suspend loop does not power down the chip again
//   86    usbirqData.inSuspend = FALSE;
        MOV     usbirqData + 2,#0x0
//   87 
//   88    // Perform remote wakeup by holding the USB resume signal for 10 ms
//   89    USBPOW |= USBPOW_RESUME;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.2
        MOVX    @DPTR,A
//   90    halMcuWaitMs(10);
        ; Setup parameters for call to function halMcuWaitMs
        MOV     R2,#0xa
        MOV     R3,#0x0
        LCALL   ??halMcuWaitMs?relay ; Banked call to: halMcuWaitMs
//   91    USBPOW &= ~USBPOW_RESUME;
        MOV     DPTR,#0x6201
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.2
        MOVX    @DPTR,A
//   92 
//   93    // Clear the interrupt flag
//   94    HAL_USB_INT_CLEAR();
        MOV     0x8b,#0x0
        CLR     0xe8.0
//   95 
//   96    HAL_EXIT_CRITICAL_SECTION(intState);
        MOV     A,R6
        MOV     C,0xE0 /* A   */.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
//   97 
//   98    return TRUE;
        MOV     R1,#0x1
??usbsuspDoRemoteWakeup_1:
        LJMP    ?Subroutine4 & 0xFFFF
          CFI EndBlock cfiBlock175
        REQUIRE _A_IEN0
        REQUIRE P2IFG
        REQUIRE _A_IRCON2
//   99 
//  100 } // usbsuspDoRemoteWakeup

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for serialNumber>`:
        DATA8
        DB 0
        DB 3
        DB 95
        DB 0
        DB 95
        DB 0
        DB 48
        DB 0
        DB 88
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0
        DB 0

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??HalFlashRead?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashRead

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??HalFlashWrite?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashWrite

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??HalFlashErase?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    HalFlashErase

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublAesAuth?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublAesAuth

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublAesCrypt?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublAesCrypt

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublCfg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublCfg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublExec?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublExec

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublInit?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublJump?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublJump

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ublMassErase?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ublMassErase

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??gpioInit?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??gpioInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??main?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    main

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpInit?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpFindNext?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpFindNext

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpGetDeviceDesc?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetDeviceDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpGetConfigurationDesc?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetConfigurationDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpGetInterfaceDesc?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetInterfaceDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbdpGetStringDesc?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbdpGetStringDesc

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwInit?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwResetHandler?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwResetHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwSetupHandler?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwSetupHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwSetAllEpStatus?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwSetAllEpStatus

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwReadFifo?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwReadFifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbfwWriteFifo?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbfwWriteFifo

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbirqInit?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbirqInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbirqHandler?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbirqHandler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetStatus?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetStatus

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ChangeFeature?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??ChangeFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrClearFeature?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrClearFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetFeature?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetAddress?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetAddress

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetDescriptor?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetDescriptor

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ConfigureEndpoints?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ??ConfigureEndpoints

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetConfiguration?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetConfiguration?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetInterface?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrGetInterface

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetInterface?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsrSetInterface

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsuspDoRemoteWakeup?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    usbsuspDoRemoteWakeup

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
`?<Constant {255, 255, 255, 255}>`:
        DATA8
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
`?<Constant {255, 255, 255, 255}>_1`:
        DATA8
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
`?<Constant {255, 255, 255, 255, 255, 255, 255,`:
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255
        DB 255

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA32
__Constant_7d:
        DD 125

        END
//  101 
//  102 
//  103 
//  104 //@}
//  105 /*
//  106 +------------------------------------------------------------------------------
//  107 |  Copyright 2004-2012 Texas Instruments Incorporated. All rights reserved.
//  108 |
//  109 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  110 |  granted under the terms of a software license agreement between the user who
//  111 |  downloaded the software, his/her employer (which must be your employer) and
//  112 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  113 |  unless you agree to abide by the terms of the License. The License limits
//  114 |  your use, and you acknowledge, that the Software may not be modified, copied
//  115 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  116 |  solely and exclusively in conjunction with a Texas Instruments radio
//  117 |  frequency transceiver, which is integrated into your product. Other than for
//  118 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  119 |  works of, modify, distribute, perform, display or sell this Software and/or
//  120 |  its documentation for any purpose.
//  121 |
//  122 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  123 |  PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  124 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  125 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  126 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  127 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  128 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  129 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  130 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  131 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  132 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  133 |
//  134 |  Should you have any questions regarding your right to use this Software,
//  135 |  contact Texas Instruments Incorporated at www.TI.com.
//  136 |
//  137 +------------------------------------------------------------------------------
//  138 */
// 
// 4 757 bytes in segment BANKED_CODE
//   228 bytes in segment BANK_RELAYS
//     7 bytes in segment DATA_Z
//   129 bytes in segment NEAR_CODE
//    20 bytes in segment SFR_AN
//    42 bytes in segment XDATA_I
//    42 bytes in segment XDATA_ID
// 2 167 bytes in segment XDATA_N
//   146 bytes in segment XDATA_ROM_C
//    41 bytes in segment XDATA_Z
// 
// 5 156 bytes of CODE  memory
//   142 bytes of CONST memory (+  4 bytes shared)
//     7 bytes of DATA  memory (+ 20 bytes shared)
// 2 250 bytes of XDATA memory
//
//Errors: none
//Warnings: none
